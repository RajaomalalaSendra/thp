<!DOCTYPE html>
<html class="loading" lang="fr">
  <head>
    <meta charset="utf-8">
    <link rel="stylesheet" type="text/css" href="/thp/style/bootstrap.css">
    <title>The hacking project offline</title>
  </head>
  <body class="vertical-layout vertical-menu 2-columns  menu-expanded fixed-navbar" data-open="click" data-menu="vertical-menu" data-color="bg-gradient-x-primary-blue" data-col="2-columns">
      <nav class="navbar navbar-expand-lg navbar-dark bg-primary">
        <h1 class="navbar-brand">THE HACKING PROJECT</h1>
        <button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarColor01" aria-controls="navbarColor01" aria-expanded="false" aria-label="Toggle navigation">
          <span class="navbar-toggler-icon"></span>
        </button>

        <div class="collapse navbar-collapse" id="navbarColor01">
          <ul class="navbar-nav mr-auto">
            <li class="nav-item active">
              <a class="nav-link" href="/thp">Home</a>
            </li>
            <li class="nav-item">
              <a class="nav-link" href="/thp/features">Features</a>
            </li>
            <li class="nav-item">
              <a class="nav-link" href="/thp/about">About</a>
            </li>
          </ul>
          <form class="form-inline my-2 my-lg-0">
            <input class="form-control mr-sm-2" type="text" placeholder="Search">
            <button class="btn btn-secondary my-2 my-sm-0" type="submit">Search</button>
          </form>
        </div>
      </nav>
<div class="container">
    <a type="button" class="btn btn-dark" href="/thp/semaine_1/">Semaine 1</a>
    <a type="button" class="btn btn-dark" href="/thp/semaine_2/">Semaine 2</a>
    <a type="button" class="btn btn-dark " href="/thp/semaine_3/">Semaine 3</a>
    <a type="button" class="btn btn-dark btn-lg" href="/thp/semaine_4/">Semaine 4</a>
    <a type="button" class="btn btn-dark" href="/thp/semaine_5/">Semaine 5</a>  
</div>
<div class="app-content content">
  <div class="content-wrapper">
    <div class="content-wrapper-before"></div>
    <div class="content-header row"></div>
    
      <div class="container">
    <div class="card">
  <div class="card-header">
    <h4 class="text-center"> Programme jour par jour</h4>
  </div>
  <div class="card-body">
    <div class="text-center">
    <a href="/thp/semaine_4">
      <button class="btn btn-secondary btn-outline-dark btn mr-4">
        <i class="fa fa-terminal"></i>&nbsp;&nbsp;&nbsp;Lun
      </button>
</a>    <a href="/thp/semaine_4/jour_2">
      <button class="btn btn-secondary btn-outline-dark btn mr-4">
        <i class="fa fa-code"></i>&nbsp;&nbsp;&nbsp;Mar
      </button>
</a>    <a href="/thp/semaine_4/jour_3">
      <button class="btn btn-secondary btn-outline-dark btn-lg mr-4">
        <i class="fa fa-desktop"></i>&nbsp;&nbsp;&nbsp;Mer
      </button>
</a>    <a href="/thp/semaine_4/jour_4">
      <button class="btn btn-secondary btn-outline-dark btn mr-4">
      <i class="fa fa-folder-open"></i>&nbsp;&nbsp;&nbsp;Jeu
      </button>
</a>    <a href="/thp/semaine_4/jour_5">
      <button class="btn btn-secondary btn-outline-dark btn mr-4">
      <i class="fa fa-bullhorn"></i>&nbsp;&nbsp;&nbsp;Ven
      </button>
</a>    </div>
  </div>
</div>


<div class="app-content content">
  <div class="content-wrapper">
    <div class="content-wrapper-before"></div>
    <div class="content-header row"></div>
    
      
<div class="content-body">
      <h2 class="text-center">Passage de SQL à ActiveRecord</h2>
      <h4 class="text-center">Initiation à Rails</h4>
  <div class="row">
     <div class="col-xl-3 col-lg-6 col-md-12">
  <div class="card">
    <div class="card-content">
      <div class="card-body">
        <div class="media d-flex">
          <div class="align-self-top">
              <i class="ft-calendar icon-opacity info font-large-4"></i>
          </div>
          <div class="media-body text-right align-self-bottom mt-3">
              <span class="d-block mb-1 font-medium-1"></span>
              <h3 class="info mb-0">
                 Jour 24 / 55</h3>
          </div>
        </div>
        <div class="progress progress-sm mt-1 mb-0 box-shadow-2">
            <div class="progress-bar bg-gradient-x-info" role="progressbar" style="width: 43%" aria-valuenow="25" aria-valuemin="0" aria-valuemax="120">
            </div>
        </div>
      </div>
    </div>
  </div>
 </div>


    <div class="col-xl-3 col-lg-6 col-md-12">
  <div class="card">
    <div class="card-content">
      <div class="card-body">
        <div class="media d-flex">
          <div class="align-self-top">
            <i class="ft-heart icon-opacity danger font-large-4"></i>
          </div>
          <div class="media-body text-right align-self-bottom mt-3">
            <span class="d-block mb-1 font-medium-1">Jokers restant</span>
            <h3 class="danger mb-0">
                3
            </h3>
          </div>
        </div>
      </div>
    </div>
  </div>
</div>

    <div class="col-xl-3 col-lg-6 col-md-12">
    <div class="card">
        <div class="card-content">
            <div class="card-body">
                <div class="media d-flex">
                    <div class="align-self-top">
                        <a href="/dashboard/assignments?locale=fr">
                           <i class="ft-fast-forward icon-opacity warning font-large-4"></i>
</a>                    </div>
                    <div class="media-body text-right align-self-bottom mt-3">
                        <span class="d-block mb-1 font-medium-1">Missions</span>
                            <div class="badge border-danger danger badge-border">Pas inscrit</div>
                    </div>
                </div>
            </div>
        </div>
    </div>
</div>

  </div>
  <div class="row">
        <div class="container">
    <div class="col-xl-12 col-lg-12 col-md-12">
    <div class="card">
        <div class="card-header">
        <h1 >Initiation à Rails
                <i class="fa fa-space-shuttle text-danger"></i>
        </h1>
        
        </div>
        <div class="card-content">
        <div class="card-body">
            <div class="card-text">
            <h2 class="text-center">Passage de SQL à ActiveRecord</h2>
            <div class="cd-horizontal-timeline loaded">
                <div class="timeline">
                <div class="events-wrapper">
                    <div class="events" style="width: 1800px;">
                    <ol>
                                <li>
                                    <a style="left:120px;" href="/dashboard/weeks/4/days/1?locale=fr">
                                        Lun
                                            <i class="fa fa-beer text-warning" aria-hidden="true" data-toggle="tooltip" data-placement="bottom" title="Rendez-vous pour boire un coup"></i>

</a>                                </li>
                                <li>
                                    <a style="left:240px;" href="/dashboard/weeks/4/days/2?locale=fr">
                                        Mar
                                            <i class="fa fa-beer text-warning" aria-hidden="true" data-toggle="tooltip" data-placement="bottom" title="Rendez-vous pour boire un coup"></i>

</a>                                </li>
                            <li>
                                <a class="selected" style="left:360px;" data-toggle="tooltip" data-placement="top" title="Passage de SQL à ActiveRecord" href="/dashboard/weeks/4/days/3?locale=fr">
                                    Mer
                                        <i class="fa fa-rocket text-danger" aria-hidden="true" data-toggle="tooltip" data-placement="bottom" title="Projet à rendre ce jour-là"></i>

</a>                                </li>
                                <li>
                                    <a style="left:480px;" href="/dashboard/weeks/4/days/4?locale=fr">
                                        Jeu
                                            <i class="fa fa-rocket text-danger" aria-hidden="true" data-toggle="tooltip" data-placement="bottom" title="Projet à rendre ce jour-là"></i>
    <i class="fa fa-pencil text-success" aria-hidden="true" data-toggle="tooltip" data-placement="bottom" title="Corrections cette journée là" ></i>

</a>                                </li>
                                <li>
                                    <a style="left:600px;" href="/dashboard/weeks/4/days/5?locale=fr">
                                        Ven
                                            <i class="fa fa-pencil text-success" aria-hidden="true" data-toggle="tooltip" data-placement="bottom" title="Corrections cette journée là" ></i>


</a>                                </li>
                    </ol>
                </div>
                </div>
            </div>
            </div>
        </div>
        </div>
    </div>
    </div>
<div>
  </div>

  <!-- Les fameuses corrections qui n'arrivnet que les jours concernés -->


    <div class="container">
  <div class="row">
    <div class="col-12">
      <div class="card">
        <div class="card-header" style="border-top: 3px solid #5E66E5 " >
          <h1>Cours : Ta première application Rails</h1>
          <a class="heading-elements-toggle">
          <i class="la la-ellipsis-v font-medium-3"></i>
          </a>
          <div class="heading-elements">
            <ul class="list-inline mb-0">
              <li><a data-action="collapse"><i class="ft-minus"></i></a></li>
              <li><a data-action="expand"><i class="ft-maximize"></i></a></li>
            </ul>
          </div> 
      </div>
      <div class="card-content collapse show">
        <div class="card-body">
          <div class="tab-pane active" id="home1" role="tabpanel">
          <h2>1. Introduction</h2>
<p>On a vu ensemble Sinatra : un langage bas-niveau qui permet de faire du web de manière simple et où le développeur a la maîtrise de son application. L'avantage pour nous est que son aspect minimaliste te fait mettre les mains dans le cambouis et te fait comprendre comment marchent les requêtes. Le défaut est que tu es entièrement maître de l'architecture de l'application, ce qui n'est pas forcément simple à gérer en tant que développeur débutant. Plus ton application va devenir complexe, plus tu vas devoir prendre des décisions sur la façon d'organiser les différents éléments de ton code… et tu n'as pas encore l'expérience pour faire les bons choix qui s’avéreront payants à long terme ! Maintenant on va passer à Rails qui impose des conventions assez fortes : l'avantage, c'est qu'elles te guident dans tes choix. Et du coup ça se passe, comme sur des rails 🚂.</p>

<p>Hier, on a abordé les bases de données et c'est chouette, très chouette, de faire du SQL. Mais à partir de maintenant, nous allons passer par une surcouche de Rails pour gérer nos BDD : ActiveRecords.</p>

<p>Pour les trois prochains jours, nous n'allons faire que du backend, et 0 frontend avec plusieurs objectifs en tête : </p>
<ul>
  <li>Le premier est de faire une introduction tout en douceur de Ruby on Rails (RoR), étant donné que tu ne vas faire que de l'interaction avec la base de données (on va se concentrer sur la partie Model du MVC).</li>
  <li>Le second de te donner des bases robustes en création de base de données, une compétence incontournable quand on fait des applications web. Si je te demande aujourd'hui de modéliser la base de données de Tinder, tu ne saurais pas comment faire (et c'est normal). Mais d'ici à vendredi soir, tu auras les bons réflexes pour tout faire toi-même et pouvoir l'implémenter sur l'application de tes rêves.</li>
  <li>Enfin, le troisième objectif est un totem dans la création d'appli web : il faut être capable de créer des bases de données robustes basées sur des models en béton armé. Si la BDD de ton appli peut être facilement polluée par des entrées à moitié remplies et incohérentes entre elles, c'est toute ton appli qui pourra finir à la poubelle. Donc nous allons t'apprendre à construire des bases de données qui restent propres dans la durée.</li>
</ul>

<p>Dans cette ressource, tu vas créer ta première application en Ruby on Rails. Waow !</p>

<h2>2. Historique</h2>
<p>Rails a été créé en 2005 par un certain David Heinemeier Hansson, plus connu sous le nom <b>DHH</b> (super compte Twitter à suivre BTW). La genèse de Rails a eu lieu à Basecamp, la fameuse start-up de DHH, où il a imaginé un framework pour faire du web à partir de Ruby. Rails a été conçu en privilégiant l'agilité et la création rapide, afin de pouvoir produire des applications facilement modifiables. Il a basé Rails sur plusieurs idées originales et plusieurs sont maintenant des standards de l'industrie (par exemple, le principe de migrations que l'on va découvrir ensemble).</p>

<div class="card box-shadow-0 border-success">
  <div class="card-content collapse show">
    <div class="card-body">
      <h4 class="card-title">📚 INSTANT CULTURE GÉ</h4>
      <p class="card-text">DHH a fait d'autres choses dans sa vie que bouleverser le monde du web. Je considère personnellement BaseCamp, l'entreprise dont il est co-fondateur et CTO, comme l'une des toutes premières startup de l'ère moderne, <i>à la</i> Trello, Slack, et son livre <a href="https://basecamp.com/books/rework" target="_blank">REWORK</a> est une bible du management moderne d'entreprise.</p>
    </div>
  </div>
</div>

<p>Rails est basé sur plusieurs philosophies :</p>
<ul>
  <li><b>Convention Over Configuration</b> : là où Sinatra te donne absolument tous les droits pour faire ce que tu veux pour tes applications, une application Rails est structurée dès sa création. Elle est "livrée" avec son dossier controller, son fichier routes, son système de bases de données. Ces conventions sont géniales pour aller plus vite dans la réalisation d'applications, la contrepartie est qu'en sortir (le jour où tu seras un demi-dieu du dev) relève du parcours du combattant.</li>
  <li><b>Don't Repeat Yourself</b> (DRY) : Rails de donne la possibilité de facilement réunir ton code dans des fichiers afin de les rappeler à plusieurs endroits de ton app. Ainsi, inutile d'écrire 2 fois la même chose ! C'est du coup plus facile à lire (on ne lit qu'une fois et pas 10) et plus facile à modifier (à un seul endroit, pas à 10).</li>
</ul>

<p>Au fil des années, Rails est devenu un langage de programmation très populaire dans l'univers du web, avec un apogée en 2011. Son principe de migration a inspiré le reste du web actuel, et sa rapidité de mise en œuvre couplée à une puissance et rapidité d'exécution en font un outil encore très populaire. Rails et Ruby sont moins en vue ces derniers temps, mais leur popularité reste très convenable, avec des jolis noms utilisant la techno : Algolia, Airbnb, Qonto, Drivy, JobTeaser, SoundCloud, Github, The Hacking Project, pour ne citer qu'eux.</p>

<div class="card box-shadow-0 border-info">
  <div class="card-content collapse show">
    <div class="card-body">
      <h4 class="card-title">🤓 QUESTION RÉCURRENTE</h4>
      <p class="card-text"><b>Mais si Ruby et Rails sont en perte de vitesse, on ne perd pas notre temps à apprendre ce framework et ce langage ?</b><br>
      Absolument pas. Et cela pour plusieurs raisons :</p>
      <ul>
        <li>La communauté Ruby et Rails est plus restreinte que celle de langages plus populaires mais elle est très active : de nombreux projets open-source (dont Rails) sont mis à jour tous les mois.</li>
        <li>C'est aussi une communauté de qualité : les documentations sont généralement bonnes et l'aide est facile à trouver via une recherche Google. Sans parler du fait que la <a href="https://dev.to/ben/ruby-has-the-kindest-programming-community-and-i-have-the-data-to-prove-it-4f60">communauté Ruby est globalement bienveillante</a>. Tous les langages ne peuvent pas en dire autant. 😏 </li>
        <li>Ils se sont imposés dans le paysage du web et ne sont clairement pas en position de disparaître sous peu. Rails et Ruby ont encore de beaux jours devant eux !</li>
        <li>Last but not Least : en termes de facilité de mise en œuvre et de rapidité de prise en main, Rails n'a pas d'égal. Et dans un bootcamp comme THP, sur 11 semaines, un débutant ne pourrait pas faire tout ce qu'on va te présenter avec un autre framework. Du coup, apprendre Rails c'est super gratifiant pour un débutant : ça augmente nettement tes chances d'aller au bout de la formation et poursuivre dans la voie du développement. </li>
      </ul>
      <p>Au final, Ruby + Rails est une super porte d'entrée dans le monde du développement. Mais pas seulement ! Nombreux sont ceux qui restent sur cette stack à l'issue de THP. <br>
      => On espère que tu seras convaincu de tout cela à l'issue des 11 semaines. Ce sera alors ton tour d'évangéliser les sceptiques. 🤗 </p>
    </div>
  </div>
</div>



<h2>3. La ressource</h2>
<h3>3.1. Rails en bref</h3>

<p>Aujourd'hui, on va (enfin !) faire du Rails. Mais avant ça, rappelons les bases : Rails est un framework web, open-source et écrit en Ruby. Ce framework est pensé avant tout pour les devs et suit deux principes : "Convention over configuration" et "Don't repeat yourself (DRY)". Rails est assez rigide dans sa manière de faire mais une fois maîtrisé, tu deviens hyper efficace en le manipulant ! En comparaison, là où créer une fonctionnalité en Rails nécessite une dizaine de lignes de code, il en faudrait cinquantaine en Sinatra.</p>

<h3>3.2. Créer son app rails</h3>

<p>Prêt ? C'est le moment de gloire où tu vas créer ta première application Rails. Ouvre donc ton terminal et déplace-toi dans ton répertoire de travail. Tape la commande :</p>

<pre><code class="language-shell">$ rails new my_first_app</code></pre>
<p>Cela va créer un nouveau dossier Rails nommé <code>my_first_app</code>. Tu n'as plus qu'a te déplacer dans ce répertoire et lancer la fameuse commande :</p>

<pre><code class="language-shell">$ bundle install</code></pre>

<p>Tadam ! Tu as créé ta première app Rails ! Prenons deux secondes pour nous recueillir et profiter de ce moment historique. <br>
OK. <br>
Maintenant, regarde un peu ton dossier Rails : tu remarqueras qu'une app rails comporte énormément de dossiers et de sous-dossiers. C'est impressionnant au début mais c'est normal. Aujourd'hui, nous allons travailler essentiellement avec le dossier <b>db</b> qui se trouve à la racine et avec le sous-dossier <b>model</b> qui se trouve dans le dossier <b>app</b>. Si tu ouvres le contenu de ton dossier avec ton éditeur de texte, tu devrais avoir une architecture du type : </p>
<pre><code class="language-shell">.
|-- app
|   |-- assets
|   |   |-- images
|   |   |-- javascripts
|   |   |   `-- application.js
|   |   `-- stylesheets
|   |       `-- application.css
|   |-- controllers
|   |   |-- application_controller.rb
|   |   `-- concerns
|   |-- helpers
|   |   `-- application_helper.rb
|   |-- mailers
|   |-- models
|   |   `-- concerns
|   `-- views
|       `-- layouts
|           `-- application.html.erb
|-- bin
|   |-- bundle
|   |-- rails
|   |-- rake
|   |-- setup
|   `-- spring
|-- config
|   |-- application.rb
|   |-- boot.rb
|   |-- database.yml
|   |-- environment.rb
|   |-- environments
|   |   |-- development.rb
|   |   |-- production.rb
|   |   `-- test.rb
|   |-- initializers
|   |   |-- assets.rb
|   |   |-- backtrace_silencers.rb
|   |   |-- cookies_serializer.rb
|   |   |-- filter_parameter_logging.rb
|   |   |-- inflections.rb
|   |   |-- mime_types.rb
|   |   |-- session_store.rb
|   |   `-- wrap_parameters.rb
|   |-- locales
|   |   `-- en.yml
|   |-- routes.rb
|   `-- secrets.yml
|-- config.ru
|-- db
|   `-- seeds.rb
|-- Gemfile
|-- Gemfile.lock
|-- lib
|   |-- assets
|   `-- tasks
|-- log
|-- public
|   |-- 404.html
|   |-- 422.html
|   |-- 500.html
|   |-- favicon.ico
|   `-- robots.txt
|-- Rakefile
|-- README.rdoc
|-- test
|   |-- controllers
|   |-- fixtures
|   |-- helpers
|   |-- integration
|   |-- mailers
|   |-- models
|   `-- test_helper.rb
|-- tmp
|   `-- cache
|       `-- assets
`-- vendor
`-- assets
    |-- javascripts
    `-- stylesheets</code></pre>

<p>Si tu regardes bien, il y a certains fichiers que tu as déjà vus :
<ul>
  <li><b>Gemfile</b> : ⚠️ Attention à bien avoir les versions THP de Ruby et Rails sinon tu risques de perdre des points bêtement lors des prochains projets ⚠️</li>
  <li><b>App/views</b> : Dans ce dossier, tu pourras concevoir l'ensemble de la partie visuelle de ton app.</li>
  <li><b>App/controllers</b> : Ce dossier contiendra tes controllers qui font le lien entre tes vues et tes modèles.</li>
  <li><b>App/model</b> : C'est ici que se trouve toute la logique qui lie les objets Ruby (utilisables ensuite dans les controllers et views) avec des tables SQL (la BDD).</li>
  <li><b>Config/routes.rb</b> : c'est ici où tu peux créer tes routes (statiques comme dynamiques).</li>
  <li><b>/db</b> : C'est là que se trouve la base de données de l'app.</li>
</ul>

<p>Pour en savoir un peu plus, tu peux regarder <a href="https://youtu.be/2MdBvjYtE18?list=PLjwdMgw5TTLWfI1B2Wv2WPgR9iOyw12zi&t=236" target="_blank">cette vidéo</a> de Grafikart à partir de la minute 4, jusqu'à la minute 9. Pas de panique si tu ne comprends pas tout, ces notions seront développées plus tard 😏</p>



<h2>4. Points importants à retenir</h2>
<p>Rails est un framework de Ruby qui permet de faire du web, créé en 2005 par David Heinemeier Hansson. Sa force réside dans sa rapidité de mise en place, et (entre autres) dans sa façon très souple de gérer des bases de données.</p>

<p>Pour créer une application Rails, il suffit de faire <code>$ rails new nom_de_mon_app</code>. <br>
Cette commande crée automatiquement tout une architecture logicielle à laquelle il faut se conformer.</p>


<h2>5. Pour aller plus loin</h2>
<p>Rails a l'une des meilleures docs qui existe, avec les Rails Guides. Un peu obscurs au début, ces guides te seront d'une aide plus que précieuse quand tu auras un niveau intermédiaire. Tu peux la parcourir mais c'est probablement un peu tôt pour aller checker <a href="https://guides.rubyonrails.org/">la documentation officielle</a>.</p>
          </div>
        </div>
        </div>
      </div>
    </div>
  </div>
</div>

  <div class="container">
  <div class="row">
    <div class="col-12">
      <div class="card">
        <div class="card-header" style="border-top: 3px solid #5E66E5 " >
          <h1>Cours : Rails Model: les BDD en Rails (migrations, création, etc.)</h1>
          <a class="heading-elements-toggle">
          <i class="la la-ellipsis-v font-medium-3"></i>
          </a>
          <div class="heading-elements">
            <ul class="list-inline mb-0">
              <li><a data-action="collapse"><i class="ft-minus"></i></a></li>
              <li><a data-action="expand"><i class="ft-maximize"></i></a></li>
            </ul>
          </div> 
      </div>
      <div class="card-content collapse show">
        <div class="card-body">
          <div class="tab-pane active" id="home1" role="tabpanel">
          <h2>1. Introduction</h2>
<p>Maintenant que tu as vu SQL, un puissant langage qui permet d'interagir avec des bases de données, on va t'expliquer comment Ruby on Rails gère les BDD. Tout s'articule autour d'une gem nommée <a href="https://github.com/rails/rails/tree/master/activerecord" target="_blank">ActiveRecord</a> qui permet de transformer une table de BDD (les fameux tableaux Excel dans lesquels on stocke les données) en classe Ruby (et donc en objet et instances). L'alliance des deux va transformer les requêtes SQL un peu barbares comme <code>SELECT * from User</code> en un plus simple <code>User.all</code> en Ruby.</p>

<p>Cette ressource sera conséquente et va faire le lien entre 2 choses que tu viens à peine de découvrir : la POO et les BDD. Prends bien le temps de la comprendre ! Quitte à la relire plusieurs fois (et ce week-end) si besoin. <br>
On va t'expliquer 4 concepts clés dans la modélisation de bases de données en Rails :</p>

<ol>
  <li>Qu'est-ce qu'ActiveRecord ;</li>
  <li>Les migrations ;</li>
  <li>Le model dans Rails ;</li>
  <li>Comment lier tables et models entre eux dans Rails.</li>
</ol>

<h2>2. Historique</h2>
<p>L'une des idées novatrices que Rails a apporté dans le monde du web, c'est la façon dont ses applications gèrent leurs bases de données. Déjà, utiliser ActiveRecord lui permet de transformer ses tables de BDD en objets Ruby. On retire une information de la BDD (par exemple le prénom d'un utilisateur) sous la forme d'un simple <code>mon_user.first_name</code>.</p>

<p>Ensuite, le principe de migration a permis d'avoir des bases de données facilement modifiables alors même que l'application tourne déjà. C'est crucial pour toute jeune entreprise qui avance à tatons (aka les startups). On verra plus en détails ce qu'est une migration mais, en gros, l'idée est d'avoir un dossier qui contient tout l'historique de tous les changements faits sur ta base de données. Le principe de migration est devenu rapidement très populaire et une bonne partie des frameworks web modernes l'utilisent désormais.</p>



<h2>3. La ressource</h2>
<h3>3.1. ActiveRecord dans Rails</h3>
<p>Tu as vu récemment le modèle MVC en Ruby, qui te permet de décomposer un programme : la partie M est le Model, soit celle qui interagit avec ta base de données. Pour le moment, tes modèles ne jouaient qu'avec des fichiers CSV, et tu as vu hier que SQL était THE langage de prédilection pour interagir avec une BDD. Eh bien grâce à ActiveRecord, nous pouvons faire tout ceci d'un coup !</p>

<p>ActiveRecord est une gem implémentée dans Rails qui décompose toutes tes tables en classes Ruby. Dit autrement, dans ton application, tu ne seras pas obligé de travailler avec du SQL : tu pourras définir tes models de base de données comme tu définis une classe Ruby. Et c'est ultra pratique.</p>


<h3>3.2. Les migrations</h3>
<h4>3.2.1. Qu'est-ce qu'une migration ?</h4>
<h5>3.2.1.1. Avant les migrations</h5>
<p>Quand tu crées une application Rails, ton fichier <code>base_de_données.sql</code> est vide. 0 table, 0 colonne. Il faut donc lui ajouter des tables et des colonnes. Avant le système de migrations, on se tapait des grosses commandes SQL du type :</p>

<pre><code class="language-sql">CREATE TABLE CUSTOMER
(
  CustomerID INT NOT NULL,
  CustomerName VARCHAR(40) NOT NULL,
  CustomerZip VARCHAR(10) NOT NULL,
  PRIMARY KEY (CustomerID)
);

CREATE TABLE SALESTRANSACTION
(
  TID INT NOT NULL,
  Tdate DATE NOT NULL,
  CustomerID INTEGER NOT NULL,
  FOREIGN KEY (CustomerID) REFERENCES CUSTOMER(CustomerID)
);</code></pre>

<p><b>Les migrations permettent d'éviter ce genre de barbarie SQL</b> : on écrit la demande de création de table dans un langage plus simple à comprendre et directement lu par Rails (inutile de jongler entre 2 interfaces, Rails et SQL).</p>

<p> Imagine maintenant le cas suivant : tu as créé une application web avec ton équipe de 5 développeurs et le site tourne plutôt bien. Vous avez déjà acquis un millier de clients et tu te rends compte que tu as fais du 💩 en créant la table des utilisateurs il y a 2 mois. Elle dispose d'une colonne <code>zip_code</code> (le code postal de l'utilisateur) que tu as mis au format <code>integer</code>. Tout allait bien jusqu'à ce que tu te rendes compte que ce n'était pas une bonne idée (quid des pays ayant des codes postaux avec des lettres ?? Ou alors le code postal de Nice qui passe de <code>06000</code> à <code>6000</code> ??). Tu aimerais donc bien passer tous tes codes postaux en <code>string</code>, un format bien plus approprié. Bien entendu (et c'est là un point crucial de ton business naissant), ta base de données est déjà pleine : tu veux conserver tous les codes postaux des utilisateurs déjà en base !!</p>

<p>Dans une BDD, avant les migrations, tu te serais tapé un max d'opérations en SQL pour mettre la BDD de ton ordinateur (qui te permet de tester l'app Rails) à jour. Il aurait fallu 1) créer une 2ème table avec une colonne <code>zip_code</code> de type <code>string</code>, 2) copier coller chaque entrée de la table originelle vers la nouvelle, 3) supprimer l'ancienne table et 4) renommer la nouvelle table pour qu'elle prenne définitivement la place de l'ancienne. <b>Les migrations automatisent (en 1 ligne) ces opérations de changement tout en conservant les données existantes</b>. </p>

<p>Une fois ces opérations SQL validées, il aurait fallu les appliquer à la BDD de ton app en PROD (celle qui tourne sur le serveur web et que les clients utilisent) afin de corriger ta bourde. Et finalement, tu aurais dû aussi appliquer ces modifications sur les ordinateurs de tous les devs de l'équipe pour que leur BDD à eux soit également à niveau. Bien sûr, interdiction de se rater et d'oublier une ligne SQL sur aucun ordinateur : on peut parler <a href="https://www.youtube.com/watch?v=k_yLPiPMmrw">de merdier</a> à ce niveau-là.</p>

<p>On peut même aller plus loin : finalement tu regrettes ta modification de BDD, car elle introduit un bug, fait péter toute ton application et le service est down ! Il ne te reste plus qu'à passer les commandes SQL inverses en urgence et dans le bon ordre s'il te plaît. Ta carrière de développeur va intéresser les archéologues : elle est en ruines.</p>

<b><p>Je pense que tu as pigé la puissance des migrations. En résumé, elles permettent :</p>
<ul>
  <li>De gérer les modifications de la BDD directement dans Rails (et non via une interface SQL) ;</li>
  <li>De faire des modifications de BDD sur une ligne de commande, sans perte des données existant déjà en BDD ; </li>
  <li>De facilement transférer d'une personne à l'autre les modifications à apporter à la BDD pour qu'elle soit dans l'état final souhaité (chaque ordi a sa propre BDD + celles des serveurs) ;</li>
  <li>De revenir rapidement (une commande !) en arrière en jouant une migration à l'envers.</li>
</ul></b>

<h5>3.2.1.2. Le dossier des migrations</h5>
<p>Les migrations sont consignées dans un dossier qui contient alors tout l'historique de toutes les modifications que l'on a apportées à sa base de données. Un peu comme ça :</p>

<pre><code class="language-shell">Jour 1 - création d'une table utilisateurs avec une colonne prénom et une colonne email
Jour 6 - création d'une table ville et ajout d'une relation entre les villes et les utilisateurs
Jour 15 - suppression de la colonne email chez les utilisateurs
Jour 17 - ajout d'une colonne nom de famille dans la table des utilisateurs
Jour 28 - création d'une table couscous pour lister les meilleurs adresses de la ville</code></pre>

<p>Une migration peut avoir 2 statuts : <code>up</code> ou <code>down</code>.</p>

<ul>
  <li><code>up</code> : elle a été passée et est appliquée à ta base de donnée actuelle.</li>
  <li><code>down</code> : elle n'est pas encore passée (ou a été annulée).</li>
</ul>

<p>Pour chaque migration, il y a une action pour passer de <code>down</code> à <code>up</code> (cela s'appelle "passer une migration"), et une action pour passer de <code>up</code> à <code>down</code> (cela s'appelle "faire un rollback"). Par exemple :</p>

<ul>
  <li>Pour une migration qui crée une table pour les utilisateurs :
  <ul>
    <li>L'action de <code>down</code> à <code>up</code> sera de créer une table utilisateurs</li>
    <li>L'action de <code>up</code> à <code>down</code> sera de détruire la table utilisateurs (attention, la perte de donnée est irréversible dans ce cas)</li>
  </ul></li>
  <li>Pour une migration qui ajoute une colonne <code>email</code> à la table utilisateurs :
  <ul>
    <li>L'action de <code>down</code> à <code>up</code> sera de créer une colonne <code>email</code> dans la table utilisateurs</li>
    <li>L'action de <code>up</code> à <code>down</code> sera de détruire la colonne <code>email</code> de la table utilisateurs (attention, la perte de donnée est irréversible dans ce cas)</li>
  </ul></li>
  <li>Pour une migration qui crée une table pour les utilisateurs et qui lui donne une colonne <code>first_name</code>
  <ul>
    <li>L'action de <code>down</code> à <code>up</code> sera de créer une table utilisateurs et lui créer une colonne <code>first_name</code></li>
    <li>L'action de <code>up</code> à <code>down</code> sera de détruire la colonne <code>first_name</code> de la table utilisateurs et de détruire la table (attention, la perte de donnée est irréversible dans ce cas)</li>
  </ul></li>
  <li>Bref, tu vois la logique</li>
</ul>

<div class="card box-shadow-0 border-success">
  <div class="card-content collapse show">
    <div class="card-body">
      <h4 class="card-title">📚 INSTANT CULTURE GÉ</h4>
      <p class="card-text">Pour tester si une migration est bien faite, un développeur senior va faire une série d'acions :</p>
      <ul>
        <li>Passer de <code>down</code> à <code>up</code> pour voir si elle marche bien</li>
        <li>Passer de <code>up</code> à <code>down</code> pour voir s'il est possible de revenir en arrière</li>
        <li>Repasser de <code>down</code> à <code>up</code> pour la prendre en compte</li>
      </ul>
      <p>Savoir ceci peut te valoir des points en entretien d'embauche ;)</p>
    </div>
  </div>
</div>

<h4>3.2.2. Créer et effectuer ses premières migrations</h4>
<h5>a) Créer sa première migration</h5>
<p>Toutes les migrations de ton application se trouvent dans le dossier <code>db/migrate/</code> au format <code>AAAAMMDDHHMMSS_nom_migration.rb</code> (AAAAMMDDHHMMSS = date et heure précise de création de la migration). Pour le moment tu n’en as pas, donc nous allons créer ta première migration. Avec Rails c'est facile, il suffit de rentrer la ligne de commande suivante :</p>

<pre><code class="language-shell">$ rails generate migration NomDeTaMigration</code></pre>

<p>Si tu exécutes cette commande, il devrait créer un fichier de migration qui ressemble à quelque chose comme ça :</p>


<pre><code class="language-ruby">class NomDeTaMigration < ActiveRecord::Migration[5.2]
  def change
    # ici tu mettras les modifications que tu aimerais apporter à ta base de données
  end
end</code></pre>

<p>Pour effectuer la migration (ne le fais pas pour le moment, car ta méthode <code>change</code> est vide), il te suffira de saisir la commande :</p>

<pre><code class="language-shell">$ rails db:migrate</code></pre>

<h5>b) Des exemples de migration</h5>
<p>Voici quelques exemples de migration. Pour le moment contente-toi de lire, tu pourras revenir ici ensuite quand nous passerons à la pratique.</p>

<p>Voici une migration qui dit "crée une table <code>users</code>" :</p>
<pre><code class="language-ruby">def change
  create_table :users do |t|
    t.timestamps
  end
end</code></pre>
<p>Les lignes <code>create_table :users do --- end</code> donnent l'ordre de créer une table <code>users</code> dont les colonnes vont être définies entre <code>do</code> et <code>end</code>. <br>
Pour le moment on ne définit que 2 colonnes en 1 ligne avec <code>t.timestamps</code> : il s'agit de 2 colonnes qui porteront les intitulés <code>created_at</code> et <code>updated_at</code>. Elles permettront de suivre automatiquement (pour chaque entrée de la table) la date et l'heure de création et de dernière mise à jour. C'est une bonne pratique donc Rails proposera automatiquement ces colonnes à la création d'une table. <br>
Note aussi que si cette migration est exécutée, la table <code>users</code> contiendra une 3ème colonne intitulée <code>id</code>. C'est la fameuse primary key dont on a parlé en SQL (pour identifier de façon unique chaque entrée). Cette colonne est indispensable pour gérer ta table: elle sera toujours présente donc pas besoin de la mentionner dans la migration.</p>


<p>Voici une migration qui dit "crée une table <code>users</code> et donne-lui une colonne <code>name</code>, de type string, et une colonne <code>is_admin</code>, de type booléen" :</p>
<pre><code class="language-ruby">def change
  create_table :users do |t|
    t.string :name
    t.boolean :is_admin
    t.timestamps
  end
end</code></pre>

<p>Si cette migration est exécutée, une table <code>users</code> sera créée. Cette table aura 5 colonnes : <code>id</code>, <code>name</code>, <code>is_admin</code><code>created_at</code> et <code>updated_at</code> (les deux timestamps).</p>

<div class="card box-shadow-0 border-info">
  <div class="card-content collapse show">
    <div class="card-body">
      <h4 class="card-title">🚀 ALERTE BONNE ASTUCE</h4>
      <p class="card-text">Quand tu génères une migration à partir de la ligne de commande, Rails peut comprendre, à partir du nom que tu donnes à la migration, ce que tu veux faire exactement. <br>
      Par exemple si tu veux créer une table <code>users</code>, tu fais <code>$ rails generate migration CreateUsers</code> et hop, la migration comprendra déjà la ligne <code>create_table :users</code> 😎</p>
    </div>
  </div>
</div>

<p>Voici une migration qui dit "dans la table <code>users</code> qui existe déjà, ajoute une colonne <code>email</code>, qui sera un string" :</p>

<pre><code class="language-ruby">def change
  add_column :users, :email, :string
end</code></pre>

<p>Voici une migration qui dit "dans la table <code>users</code> qui existe déjà, enlève la colonne <code>is_admin</code>" :</p>

<pre><code class="language-ruby">def change
  remove_column :users, :is_admin, :boolean
end</code></pre>

<p>Bien d'autres exemples sont <a href="http://edgeguides.rubyonrails.org/active_record_migrations.html#creating-a-migration" target="_blank">disponibles dans la doc</a> (renommer une table, etc.) et Jonathan de Grafikart a fait <a href="https://youtu.be/LBtCqTeJvfg" target="_blank">une vidéo de 10mn</a> qui explique les migrations.</p>

<div class="card box-shadow-0 border-info">
  <div class="card-content collapse show">
    <div class="card-body">
      <h4 class="card-title">🚀 ALERTE BONNE ASTUCE</h4>
      <p class="card-text">Voici quelques commandes très pratiques pour être le champion des migrations :</p>
      <ul>
        <li><code>$ rails db:migrate</code> : Cette commande exécute TOUTES les migrations du dossier <code>db/migrate</code> qui sont en statut <code>down</code>. Si tu te rends dans le dossier db après l'avoir exécutée, et ouvre le fichier development.sqlite3, tu verras que la base a été crée (et beaucoup plus facilement qu'hier en SQL).</li>
        <li><code>$ rails db:migrate:status</code> : te sort un joli tableau pour voir où tu en es dans tes migrations entre les <code>up</code> et les <code>down</code>.</li>
        <li><code>$ rails db:rollback</code> : revient en arrière sur la dernière migration. Très pratique quand on a fait une coquille qu'on détecte de suite.</li>
        <li><code>$ rails db:migrate VERSION=20180905201547</code> : annule toutes les migrations postérieures à celle portant le nom "20180905201547".</li></li>
      </ul>
    </div>
  </div>
</div>


<h4>3.2.3. À toi de jouer ! Cas pratique</h4>
<p>Trèves de blabla, à toi de jouer. Crée une table <code>users</code> avec les attributs suivants :</p>

<ul>
  <li>Un <code>email</code> qui est un <code>string</code></li>
  <li>Un <code>first_name</code> qui est un <code>string</code></li>
  <li>Un <code>last_name</code> qui est un <code>string</code></li>
  <li>Un <code>is_admin</code> qui est un <code>booléen</code></li>
  <li>Les <code>timestamps</code></li>
</ul>

<div class="card box-shadow-0 border-danger">
  <div class="card-content collapse show">
    <div class="card-body">
      <h4 class="card-title">⚠️ ALERTE ERREUR COMMUNE</h4>
      <p class="card-text">Attention à ne <b>JAMAIS changer ni supprimer</b> un fichier de migration à partir du moment où elle a été passée. Sans le fichier de migration, Rails ne saura pas quoi faire avec ta base de données donc il sera perdu.</p>
      <p>En faisant ça, tu vas créer des bugs relous à gérer voire foutre en l'air ta base de données (et tu seras bon pour l'effacer et recommencer).</p>
    </div>
  </div>
</div>

<h3>3.3. Le model</h3>
<h4>3.3.1. Créer ton model</h4>
<p>Une fois que l'on a fait ses migrations pour sa base de données, nous allons créer le model correspondant à la table. <br>
Ce qui est primordial que tu comprennes c'est que <b>pour chaque table de la BDD, il doit y avoir un model correspondant</b>. Les deux deviennent alors intimement liés grâce au travail invisible d’Active Records. Si on prend l'exemple d'une table <code>users</code> liée au model <code>User</code>, voici comment les deux sont liés : </p>
<ul>
  <li><b>Chaque entrée de la table <code>users</code> est en fait une instance de la classe <code>User</code></b>.</li>
  <li><b>On peut créer une nouvelle entrée en BDD en faisant les lignes de Ruby </b>: <code>julie = User.new("julie", "julie@gmail.com")</code> puis <code>julie.save</code>. La table <code>users</code> est alors complétée en BDD d'une nouvelle entrée avec les bonnes colonnes.</li>
  <li><b>Chaque colonne de la table est automatiquement une variable d'instance qui est déjà en <code>attr_accessor</code></b>. Par exemple si je fais en Ruby <code>julie.email</code>, je récupère bien le contenu de la colonne <code>email</code> de cet objet (par ex : "julie@gmail.com"). Et si je fais en Ruby <code>julie.email = nil</code>, puis <code>julie.save</code>, la colonne est bien modifiée en BDD. </li>
  <li>Et plein d'autres exemples que nous verrons.</li>
</ul>

<p> Mais quel est le rôle du fichier model ? Il sera dans le dossier <code>app/model</code> et aura pour objectif de définir plusieurs choses : </p>
<ul>
  <li>Les méthodes de classe qu'on veut pouvoir utiliser sur les instances ;</li>
  <li>Les validations qui sont les conditions à remplir pour qu'une entrée soit considérée comme OK et sauvegardée (ex : impossible de créer un utilisateur si le champ e-mail est vide) ;</li>
  <li>Les liens entre les différentes tables / models (1-N, N-N, etc.)</li>
</ul> 

<div class="card box-shadow-0 border-danger">
  <div class="card-content collapse show">
    <div class="card-body">
      <h4 class="card-title">⚠️ ALERTE ERREUR COMMUNE</h4>
      <p class="card-text">On te l'a dit, en Rails c'est "Convention over configuration". Comme tout model doit avoir une table et vice et versa, leurs noms doivent respecter la convention pour que Rails sache qui va avec qui. Voici les règles :
      <ul>
        <li>Le nom d'une table (définie dans une migration) sera <b>toujours</b> en pluriel snake_case. On parlera par exemple de la table <code>users</code>.</li>
        <li>Le nom de la classe de ton model sera <b>toujours</b> au singulier en CamelCase. On parlera par exemple du model <code>User</code>.</li>
        <li>Le nom de fichier de ton model sera <b>toujours</b> au singulier en snake_case. On parlera par exemple du fichier <code>user.rb</code></li>
      </ul>
      <p>Dans le doute, n'hésite pas à googler, je le fais très régulièrement !</p>
    </div>
  </div>
</div>


<p>Pour créer un model, Rails a une commande spéciale. Comme tout model est forcément lié à une table, cette commande aura pour effet de créer une migration de création de table en plus du model correspondant. Un petit 2-en-1 digne des meilleurs détergents. <br>
Voici la commande :</p>
<pre><code class="language-shell">$ rails generate model NomDeTonModel</code></pre>

<div class="card box-shadow-0 border-danger">
  <div class="card-content collapse show">
    <div class="card-body">
      <h4 class="card-title">⚠️ ALERTE ERREUR COMMUNE</h4>
      <p class="card-text">Quand on débute, on a tendance à ajouter des migrations à la va-vite sans comprendre leur implication. Si jamais tu as déjà créé la table en amont du model, tu dois supprimer la migration que Rails génère automatiquement mais bien sûr AVANT qu'elle n'ait été passée ! Sinon, au prochain <code>$ rails db:migrate</code>, Rails va te gueuler dessus que tu ne peux pas créer une table déjà existante. Ne t'en fais pas, et dis-toi que c'est pour ton bien.</p>
      <p>À partir de maintenant, essaye de créer la table et le model en même temps via la commande de génération de model. </p>
    </div>
  </div>
</div>

<div class="card box-shadow-0 border-info">
  <div class="card-content collapse show">
    <div class="card-body">
      <h4 class="card-title">🚀 ALERTE BONNE ASTUCE</h4>
      <p class="card-text">La commande de génération d'un modèle te permet même d'ajouter direct les colonnes de ta table DANS la migration. Par exemple si tu veux créer un model user avec un email qui est un string et un is_admin qui est un booléen, tu écrirais la commande :</p>
      <pre><code class="language-shell">$ rails generate model User email:string is_admin:boolean</code></pre>
      <p>Et hop, la migration est déjà toute prête. Il n'y a plus qu'à la passer pour avoir la table et ses colonnes.</p>
    </div>
  </div>
</div>

<h4>3.3.2. Tester et jouer avec ton model en base</h4>
<p>Rails dispose d'une console dans laquelle tu vas pouvoir tester la création d'instances via tes models. Elle se lance avec <code>$ rails console</code>. <br>
Lorsque ton model existera tu pourras créer un utilisateur avec <code>u = User.new</code>, changer son nom avec <code>u.first_name = "Félix"</code>, l'afficher avec <code>u</code> puis le sauver en base avec <code>u.save</code>. <br>
Pour le moment, ne fait pas de tests (on y vient juste après !) mais sache que le terminal devrait afficher quelque chose du genre : </p>

<pre><code class="language-ruby">Running via Spring preloader in process 453
Loading development environment (Rails 5.2.2)

2.5.1 :003 > u = User.new
=> #&lt;User id: nil, email: nil, first_name: nil, last_name: nil, is_admin: nil, created_at: nil, updated_at: nil> 

2.5.1 :004 > u.first_name = "Félix"
 => "Félix" 

2.5.1 :005 > u
=> #&lt;User id: nil, email: nil, first_name: "Félix", last_name: nil, is_admin: nil, created_at: nil, updated_at: nil>

2.5.1 :006 > u.save
   u = User.create
   (0.2ms)  begin transaction
  User Create (2.7ms)  INSERT INTO "users" DEFAULT VALUES
   (8.5ms)  commit transaction
=> #&lt;User id: nil, email: nil, first_name: "Félix", last_name: nil, is_admin: nil, created_at: nil, updated_at: nil>
</code></pre>

<p>Nous verrons dans la leçon suivante comment jouer avec la console de Rails, un super lieu chaleureux 🔥</p>

<h4>3.3.3. À toi de jouer ! Cas pratique</h4>
<p>Prends la table <code>users</code> de tout à l'heure et crée-lui le model correspondant. Il faut que tu sois capable de faire <code>User.create</code> (équivalent d'un <code>u = User.new</code> suivi d'un <code>u.save</code>) dans la console pour tester que le model et la table sont bien fonctionnels.</p>


<h3>3.4. Lier deux tables entre elles</h3>
<p>LE moment qui fait peur à tout le monde : comment faire en sorte que mon utilisateur puisse être lié à des articles de blog (qu'il a écrit) ? Et comment faire en sorte que chaque article ait un auteur ? Eh bien avec le mode d'emploi et un peu de rigueur, c'est pas si compliqué que ça.</p>

<p><b>Pour le moment, nous allons faire une relation 1-N, car ce sont les plus simples</b>. Pour que ton association marche, il faut ajouter une colonne d'index (<code>id</code>) dans une des deux tables, puis mentionner dans chaque modèle l'existence de cette association. C'est tout, et nous allons voir ensemble comment faire ceci - à nouveau, pour le moment, lis sans tester. Nous pratiquerons juste après et tu pourras revenir aux explications.</p>


<h4>3.4.1. Lier les tables dès leur création</h4>

<p>Prenons le cas d'un <code>Book</code>, qui aurait un <code>Author</code>. Dans ce cas, un livre n'a qu'un seul auteur, mais un auteur peut avoir écrit plusieurs livres. Nous allons commencer par créer le model <code>Author</code>, ainsi que la migration correspondante qui va créer la table <code>authors</code>: </p>

<pre><code class="language-shell">$ rails generate model Author</code></pre>

<p>Ce qui aura pour effet de créer le fichier <code>app/model/author.rb</code> et la migration suivante : </p>

<pre><code class="language-ruby">class CreateAuthors < ActiveRecord::Migration[5.2]
  def change
    create_table :authors do |t|
      t.timestamps
    end
  end
end</code></pre>

<p>Parfait. Maintenant nous allons faire de même avec le model <code>Book</code> : </p>

<pre><code class="language-ruby">$ rails generate model Book</code></pre>

<p>Cependant, tu vas devoir modifier la migration pour que la table <code>books</code> ait une information en plus : la référence de l'auteur de chaque livre. Pour faire ça, rajoute la ligne <code>t.belongs_to :author, index: true</code> dans la migration :</p>

<pre><code class="language-ruby">class CreateBooks < ActiveRecord::Migration[5.1]
  def change
    create_table :books do |t|
      t.belongs_to :author, index: true
      t.timestamps
    end
  end
end</code></pre>

<p>Cette ligne dit à ta BDD "crée une colonne qui va servir à stocker un integer, celui-ci sera la référence (l'<code>id</code>) de l'auteur qui est lié au livre". Maintenant, tu n'as plus qu'à passer tes 2 migrations : <code>$ rails db:migrate</code></p>

<p>Maintenant que l'on a bien les tables créées, il n'y a plus qu'à dire à ActiveRecord de faire le lien entre les models. Il faut dire dans notre model de book qu'il appartient à un author :</p>
<pre><code class="language-ruby">class Book < ApplicationRecord
  belongs_to :author
end</code></pre>

<p>Puis dire à notre model d’author qu'il a plusieurs books :</p>
<pre><code class="language-ruby">class Author < ApplicationRecord
  has_many :books
end</code></pre>


<div class="card box-shadow-0 border-info">
  <div class="card-content collapse show">
    <div class="card-body">
      <h4 class="card-title">🤓 QUESTION RÉCURRENTE</h4>
      <p class="card-text">
        <b>Mais dis donc Jamy, j'ai déjà vu un truc du genre </b><code>t.references :author, foreign_key: true</code><b>, quelle est la différence avec </b><code>t.belongs_to :author, index: true</code></b> ?<br>
        Absolument aucune, elles veulent dire exactement la même chose.
      </p>
      <p class="card-text">
        <b>Mais dis donc Jamy, dans une relation 1-N, comment savoir dans quelle table je mets l'index de l'autre ?</b><br>
        Il suffit de réfléchir 2 secondes et te dire "ok, l'index est <b>toujours</b> stocké au format integer. Si je mets dans la table <code>authors</code> les index de chaque bouquin qu'il a écrit, je vais en avoir parfois 1, parfois 5 ou parfois 1000. C'est pas gérable. Par contre, si je mets dans la table <code>books</code> l'index de l'auteur correspondant, comme il est unique, il n'y en aura toujours qu'un seul !" Du coup tu as ta réponse : c'est la table <code>books</code> qui porte l'index.
      </p>
      <p class="card-text">
        <b>Mais dis donc Jamy, comment on fait alors pour faire des relations N-N </i>🤔</b><br>
        On devra forcément rajouter une table entre les deux. Mais on verra ça demain 🤓
      </p>
    </div>
  </div>
</div>

<h4>3.4.2. Ajout de liens entre 2 tables déjà existantes</h4>
<p>Reprenons notre exemple avec les <code>Book</code> et les <code>Author</code> mais cette fois, imaginons que les 2 tables et les 2 models sont déjà créés <b>mais n'ont jamais encore été liés avec <code>t.belongs_to</code></b>. Aucune des 2 tables n'a de foreign key dans ce cas de figure. <br>
 Comment les lier à présent ? Il faut commencer par ajouter l'index à la table books, en faisant une migration :</p>

<pre><code class="language-bash">$ rails generate migration AddIndexToBooks</code></pre>

<p>Ensuite on rentre les lignes suivantes dans le fichier de migration, avant de la passer :</p>

<pre><code class="language-ruby">def change
  add_reference :books, :author, foreign_key: true
end</code></pre>

<p>Reste alors à modifier tes modèles pour prendre en compte les associations :</p>
<pre><code class="language-ruby">class Book < ApplicationRecord
  belongs_to :author
end</code></pre>

<pre><code class="language-ruby">class Author < ApplicationRecord
  has_many :books
end</code></pre>

<h4>3.4.3. Fonctionnellement, ça rajoute quoi une relation 1-N ? Testons en console !</h4>

<p>En ayant lié entre eux les deux models <code>Book</code> et <code>Author</code>, Rails va te permettre très facilement de passer de l'un à l'autre. <br>
Ainsi, si tu disposes d'une instance de <code>Book</code>, tu peux immédiatement récupérer l'instance <code>Author</code> qui lui est liée en faisant <code>.author</code> dessus (tu noteras le singulier de "author"). <br>
Symétriquement, si tu disposes d'une instance de <code>Author</code> tu peux immédiatement récupérer <b>un array des instances</b> <code>Book</code> qui lui sont liées en faisant <code>.books</code> dessus (tu noteras le pluriel de "books").</p>

<p>Pour tester en console et vérifier que le lien est bien fait, voici une méthode classique :</p>
<pre><code class="language-ruby">> b = Book.new("Les misérables", 1903)
#=> cela crée un book pas encore sauvegardé

> b.author
#=> tu devrais voir "nil" car aucun objet author n'est lié à ce book.
#=>S'il te renvoie une erreur, c'est que le lien entre les 2 modèles est mal fait : il faut le revoir.

> a = Author.create("Victor Hugo", "Français")
#=> on crée une instance d'Author

> b.author = a
#=> ça y est, on lie l'objet "b" (book) avec l'objet "a" (author). 
#=>S'il te renvoie une erreur, c'est que le lien entre les 2 modèles est mal fait : il faut le revoir.

> b.save
#=> On écrit l'objet "b" en BDD. S'il te renvoie une erreur, tu as mal suivi ce tuto

> livre = Book.last
#=> Récupère le dernier book écrit en base (celui que tu viens de créer)

>livre.author
#=> Renvoie théoriquement l'objet "a" (Victor Hugo)

>livre.author.books
#=> Devrait te renvoyer un array avec tous les book écrits par Victor Hugo. Parmi eux, tu devrais trouver le book que tu viens de créer</code></pre>

<p>Grâce à ceci, tu vérifies que :</p>
<ul>
  <li>Tes books sont bien liés aux authors</li>
  <li>Tes authors sont bien liés aux books</li>
</ul>

<div class="card box-shadow-0 border-info">
  <div class="card-content collapse show">
    <div class="card-body">
      <h4 class="card-title">🚀 ALERTE BONNE ASTUCE</h4>
      <p class="card-text">Parfois tu feras <code>Truc.create</code> et la console te renverra un truc ou y'a marqué en rouge <code>ROLLBACK</code>. Cela veut dire que la sauvegarde n'a pas été prise en compte. Pour remédier à ceci, la méthode <code>#errors</code> va te sauver la vie et t'expliquer ce qui a foiré. Exemple avec notre book :</p>
      <pre><code class="language-ruby">> b = Book.create
#=> ROLLBACK
> b.errors
#=> Author must exist</code></pre>
      <p class="card-text">Étant donné que ton book <code>belongs_to</code> un auteur, eh bien <b>il faut absolument qu'un auteur soit défini pour ton book AVANT de pouvoir le sauvegarder en BDD.</b> </p>
    </div>
  </div>
</div>

<h2>4. Points importants à retenir</h2>

<p>Le système de migrations a de nombreux avantages, notamment :</p>

<ul>
  <li>Ce système permet de débarquer à tout moment dans une application, savoir quelles sont les migrations qui sont faites (up) et celles qui sont à faire (down), puis de pouvoir mettre à jour sa base de données facilement. Très pratique pour travailler à plusieurs dessus.</li>
  <li>Cela permet d'avoir des bases de données dynamiques que tu peux modifier facilement. Ainsi si jamais tu n'es pas content d'un model (nom foireux, mauvaise architecture), ce sera très simple de la modifier.</li>
</ul>


<p>Les principales commandes pour jouer avec les migrations sont :</p>
<ul>
  <li><code>$ rails generate migration nom_de_ta_migration</code> : crée une migration</li>
  <li><code>$ rails db:migrate</code> : passe toutes les migrations en attente</li>
  <li><code>$ rails db:migrate:status</code> : te sort un joli tableau pour voir où tu en es dans tes migrations entre les up et les down</li>
  <li><code>$ rails db:rollback</code> : revient en arrière sur la dernière migration.</li>
</ul>

<p>Il est primordial de ne <b>JAMAIS changer ni supprimer un fichier de migration</b> à partir du moment où elle a été passée.</p>

<p>Chaque table (pluriel snake_case : <code>users</code>) doit être liée à un model (singulier CamelCase : <code>User</code>)</p>
<p>Tu peux créer un modèle et la migration permettant de créer sa table avec la commande <code>$ rails generate model NomDeTonModel</code> </p>


<p>Pour lier en 1-N deux tables et models entre eux, il faut procéder en 2 étapes : </p>
<ol>
  <li>Ajouter la clé étrangère dans <b>la table qui représente l'objet appartenant à l'autre</b>. Exemple : <code>book</code> appartient à son <code>author</code>, donc c'est <code>book</code> qui aura la clé étrangère. Soit le faire dès la création de la table, soit faire une migration avec : <code>add_reference :books, :author, foreign_key: true</code></li>
  <li>Lier les models en utilisant <code>has_many</code> et <code>belongs_to</code>.</li>
</ol>

<p>La commande <code>$ rails console</code> sera ta future nouvelle amie (mais on y reviendra). Elle te sera d'une <b>immense</b> utilité pour vérifier que tes models sont bien liés.</p>


<h2>5. Pour aller plus loin</h2>
<p>Pour te familiariser avec les migrations, tu peux aller voir <a href="https://edgeguides.rubyonrails.org/active_record_migrations.html" target="_blank">le chapitre correspondant</a>, dans la doc des Rails Guides. 🍻</p>


<p>Voici un peu de lecture pour aller plus loin que les has_many et belongs_to de la ressource et mieux survivre en terres inconnues d'associations :</p>
<ul>
  <li>Voici <a href="https://www.youtube.com/watch?v=DAjfsW4gqGo" target="_blank">une vidéo</a> qui reprend la partie sur les associations, et qui montre quelques méthodes en console pour jouer avec nos models.</li>
  <li>La doc contient une super grande page sur les associations entre différents modèles d'une app Rails, et sur les bonnes pratiques pour les réussir : <a href="http://guides.rubyonrails.org/association_basics.html" target="_blank">la voici</a>. On verra plus en détail les associations demain mais essaye de prendre ce que tu peux dans cette doc pour le projet du jour.</li>
  <li>SitePoints ont fait <a href="https://www.sitepoint.com/brush-up-your-knowledge-of-rails-associations/" target="_blank">un bon tuto</a> qui reprend les bases des associations.</li>
</ul>
          </div>
        </div>
        </div>
      </div>
    </div>
  </div>
</div>

  <div class="container">
  <div class="row">
    <div class="col-12">
      <div class="card">
        <div class="card-header" style="border-top: 3px solid #5E66E5 " >
          <h1>Cours : Rails Console, ta nouvelle meilleure amie</h1>
          <a class="heading-elements-toggle">
          <i class="la la-ellipsis-v font-medium-3"></i>
          </a>
          <div class="heading-elements">
            <ul class="list-inline mb-0">
              <li><a data-action="collapse"><i class="ft-minus"></i></a></li>
              <li><a data-action="expand"><i class="ft-maximize"></i></a></li>
            </ul>
          </div> 
      </div>
      <div class="card-content collapse show">
        <div class="card-body">
          <div class="tab-pane active" id="home1" role="tabpanel">
          <h2>1. Introduction</h2>
<p>La console de Rails est un outil extrêmement puissant qui te permet de lancer PRY, branché à ta base données. Elle te permet de :</p>

<ul>
	<li>Naviguer dans ta base de données</li>
	<li>Tester tes models</li>
	<li>Modifier ta base de données (pratique pour créer par exemple quelques utilisateurs à la volée)</li>
</ul>

<p>Dans cette ressource nous allons te montrer comment interagir avec ta base avec la console.</p>

<h2>2. Historique</h2>
<p>Heu..</p>

<h2>3. La ressource</h2>

<h3>3.1. La console</h3>
<p>La console rails est ultra importante pour tester les BDD et est surtout hyper facile d'utilisation. Il suffit de taper la ligne de commande <code>$ rails console</code> dans ton Terminal pour y avoir accès. Basée sur PRY, elle te permet d'exécuter du Plain Old Ruby, directement via le terminal.</p>

<p>À partir de là, tu peux tester plein de méthodes !</p>

<pre><code class="language-ruby">Running via Spring preloader in process 8287
Loading development environment (Rails 5.2.2)
2.5.1 :001 > puts "Hello"
Hello
 => nil 
2.5.1 :003 > u = User.create
   (0.2ms)  begin transaction
  User Create (0.6ms)  INSERT INTO "users" DEFAULT VALUES
   (6.5ms)  commit transaction
 => #<User id: 4, timestamps: nil, name: nil> 
2.5.1 :004 > u.name
 => nil 
2.5.1 :005 > u.name = "Félix"
 => "Félix" 
2.5.1 :006 > u.save
   (0.2ms)  begin transaction
  User Update (0.7ms)  UPDATE "users" SET "name" = ? WHERE "users"."id" = ?  [["name", "Félix"], ["id", 4]]
   (9.2ms)  commit transaction
 => true </code></pre>

<p>Nous allons voir ensemble les méthodes que tu peux utiliser dans la console pour t'amuser avec tes models.</p>

<div class="card box-shadow-0 border-info">
  <div class="card-content collapse show">
    <div class="card-body">
      <h4 class="card-title">🚀 ALERTE BONNE ASTUCE</h4>
      <p class="card-text">Tu peux lancer la console en mode sandbox grâce à l'option <code>$ rails console --sandbox</code>. Cela fera perdre toutes les données que tu as enregistrées lorsque tu quitteras la console. Pratique pour tester des models à la volée.</p>
      <p>La console tu vas t'en servir trèèès souvent. Balance un alias pour la lancer rapidement 😉</p>
    </div>
  </div>
</div>


<h3>3.2. Les méthodes importantes</h3>
<h4>3.2.1. Le CRUD</h4>
<p>Le CRUD, encore ? Et oui. Le CRUD est à la base de toute application rails, donc autant s'y faire dès aujourd'hui. On y reviendra la semaine prochaine, mais sache que toute action dans le MVC de rails sera forcément l'une des 4 actions du CRUD. Bref, passons à la suite.</p>

<p>Une fois ton model créé, et lié à une table en base, te voici prêt à t'amuser avec la console. Ça va tout déchirer, car les commandes pour faire un CRUD en sont bien plus faciles que du SQL classique : on exécute des commandes sur notre model et les méthodes sont du ruby classique. Par exemple pour retrouver tous les utilisateurs c'est aussi simple que : <code>User.all</code>.</p>

<p>Voici sans plus tarder quelques fonctions de base pour interagir avec ta base de données, nous allons reprendre le CRUD vu hier :</p>

<h5>3.2.1.1. Create</h5>

<pre><code class="language-ruby">> martin = User.new(name: "Martin", email: "martion@gmail.com")
> martin.save</code></pre>

<p>ou</p>

<pre><code class="language-ruby">> martin = User.create(name: "Martin", email: "martion@gmail.com")</code></pre>

<p> <code>#create</code> est l'équivalent d'un <code>#new</code> suivi d'un <code>#save</code></p>

<h5>3.2.1.2. Read</h5>
<pre><code class="language-ruby">> u = User.find(3) # trouve l'utilisateur avec id = 3
> u.name #=> Affiche le prénom</code></pre>

<pre><code class="language-ruby">> david = User.find_by(name: 'David')
> david #=> donnera le premier résultat qui match ou retournera nil si il n'y a aucun résultat</code></pre>

<p>Il est possible de faire des recherches plus complexes avec la méthode <code>#where</code>:

<pre><code class="language-ruby">> users = User.where(name: 'David', age: 22).order(created_at: :desc)
# Cette ligne nous donnera tout les david de 22 ans par ordre chronologique.</code></pre>

<p>⚠️ Pour trier par âge, il faut avoir une colonne âge dans son model User !</p>

<h5>3.2.1.3. Update</h5>
<pre><code class="language-ruby">> user_1 = User.find(1)
> user_1.name = "a new name"
> user_1.save</code></pre>

<p>ou</p>

<pre><code class="language-ruby">> user_1 = User.find(1)
> user_1.update(name: "a new name")</code></pre>

<p>Il est bien entendu possible d'utiliser une méthode <code>#where</code> pour trouver l'élément à modifier.

<h5>3.2.1.4. Delete</h5>
<pre><code class="language-ruby">> user_1 = User.find(1)
> user_1.destroy</code></pre>

<h5>3.2.1.5. À toi de jouer !</h5>
Pour t'entraîner tu vas créer 5 profils avec la commande <code>create</code> et 5 avec les commandes <code>new</code> et <code>save</code>. Ensuite tu vas les rechercher avec <code>find</code> et <code>find_by</code>. Tu devras modifier le nom et/ou le mail de certains profils et en supprimer d'autres qui répondent à des critères que tu auras fixés (supprimer tous les utilisateurs qui s'appellent "Jack" par exemple. Une fois à l'aise, tu peux attaquer la suite. Maîtriser la console est <b>essentiel</b> pour pouvoir tester sa base rapidement en créant des instances et en vérifiant qu'elles font bien ce pour quoi elles ont été conçues. </p>


<h4>3.2.2. Quelques méthodes</h4>


<p> 🎁BONUS 🎁: La liste des fonctions préférées du dev THP
<ul>
  <li><code>#all</code> : te ressort tout les éléments de ton modèle</li>
  <li><code>#new</code> : créer une nouvelle instance de ton modèle</li>
  <li><code>#save</code> : enregistre cette instance</li>
  <li><code>#create</code> : créer et enregistre une instance de modèle</li>
  <li><code>#update(attribute: value)</code> : met à jour ton model</li>
  <li><code>#last</code> : pour vérifier la dernière entrée en base</li>
  <li><code>#first</code> : pareil mais pour la premiere</li>
  <li><code>#find_by(attribute: value)</code> : pour rechercher une valeur spécifique</li>
  <li><code>#where(attribute: value)</code> : te ressort tous les éléments qui ont <code>value</code> à l'<code>attribute</code></li>
</ul>

<div class="card box-shadow-0 border-danger">
  <div class="card-content collapse show">
    <div class="card-body">
      <h4 class="card-title">⚠️ ALERTE ERREUR COMMUNE</h4>
      <p class="card-text">Certaines de ces méthodes vont te ressortir un objet, d'autres une array. Fais donc attention avant de te lancer dans des <code>.email</code> pointés à des arrays ;)</p>
    </div>
  </div>
</div>



<h4>3.2.3. Tester ses models</h4>
<p>Ce pourquoi j'utilise très souvent la console est que je peux tester très rapidement si mes models sont bien liés entre eux. Fais-le tout le temps. Apprends à maîtriser ceci, puisque si tu sais le faire en console, tu sauras le faire dans ton programme. Voici par exemple comment tester que Book appartient bien à Author et Author a plusieurs books :</p>

<pre><code class="language-ruby">> b = Book.new
#=> Super un book pas encore sauvegardé
> b.author
#=> il te renvoie nil. S'il te renvoie une erreur, tu as mal suivi ce tuto
> a = Author.first
#=> un superbe auteur. S'il n'a rien, crée un truc
> b.author = a
#=> pas d'erreur
> b.save
#=> COMMIT. S'il te renvoie une erreur, tu as mal suivi ce tuto
> Book.last.author.books #=> Récupère les books de l'author du dernier book que tu as en base (celui que tu viens de créér)
#=> Devrait te renvoyer une array qui contient le book que tu viens de créér</code></pre>


<h4>3.2.4. Bonus</h4>
<p>Puisque c'est toi, voici quelques méthodes en bonus que tu peux copier-coller dans ta console pour t'amuser/</p>

<h5>3.2.4.1. Créer 100 users</h5>
<p>Voici quelques lignes pour créer 100 utilisateurs :</p>
<pre><code class="language-ruby">100.times do |index|
	u = User.create
	u.name = "TonPrénom" + index.to_s
	u.email = "email_#{index}@email.com"
	u.save
end</code></pre>


<h5>3.2.4.2. Visualiser la base de données</h5>
<p>On me demande souvent si c'est possible d'utiliser un soft qui permet de visualiser sa base de données. Ce à quoi je réponds : "c'est une view dans ton app ça" ou alors "la console est faite pour". Pour toi, voici une astuce pour afficher la base de données dans la console en mode "gros BG de l'écran noir". Pour ceci, il faudra passer par la gem <a href="https://github.com/arches/table_print" target="_blank">table_print</a>. Mets-la dans ton Gemfile, puis <code>bundle install</code>, puis tu n'as plus qu'à l'activer dans ta console avec :</p>

<pre><code class="language-ruby">tp User.all</code></pre>

<p>Avoue que c'est assez BG quand même.</p>



<h2>4. Points importants à retenir</h2>
<p>La console est ta meilleure amie. Utilise la TOUT LE TEMPS.</p>

<h2>5. Pour aller plus loin</h2>
<p>Nous te conseillons de jeter un oeil attentif à ceci :  notre ami Jonathan a fait une <a href="https://youtu.be/UsuFC9-Irzw" target="_blank" class="text-primary">vidéo où il s'amuse avec la console</a>, car la compréhension de la console est <b>indispensable</b> pour bien gérer tes modèles pour les prochains jours. Tu peux la regarder jusqu'à 12:59 (il parle du controller après, et cela ne nous concerne pas pour le moment).</p>

<p>Pour plus d'informations sur les requêtes en ActiveRecord, la <a href="https://guides.rubyonrails.org/active_record_querying.html" target="_blank">doc</a> contient beaucoup d"info utiles (comme d'habitude).</p>

          </div>
        </div>
        </div>
      </div>
    </div>
  </div>
</div>

  <div class="container">
  <div class="row">
    <div class="col-12">
      <div class="card">
        <div class="card-header" style="border-top: 3px solid #5E66E5 " >
          <h1>Cours : Seed</h1>
          <a class="heading-elements-toggle">
          <i class="la la-ellipsis-v font-medium-3"></i>
          </a>
          <div class="heading-elements">
            <ul class="list-inline mb-0">
              <li><a data-action="collapse"><i class="ft-minus"></i></a></li>
              <li><a data-action="expand"><i class="ft-maximize"></i></a></li>
            </ul>
          </div> 
      </div>
      <div class="card-content collapse show">
        <div class="card-body">
          <div class="tab-pane active" id="home1" role="tabpanel">
          <h2>1. Introduction</h2>
<p>Remplir sa base de données à la main peut être fastidieux. Et si on trouvait un moyen de remplir 100 books, comme ça c'est la fête et on a juste à siroter un café pendant que notre ordinateur le fait ? Mais c'est tout bonnement l'intérêt de l'informatique 🎉</p>

<p>Les seeds vont te demander de <b>bien</b> comprendre le backend puisque tu vas créer plein d'éléments en base, qui doivent être corrects. Ce sera une super occasion d'approfondir tes bases en backend et Model.</p>

<h2>2. Historique</h2>
<p>Boarf, y'a pas grand chose à dire, si ce n'est que c'est la meilleure technique pour tester en local ton application.</p>

<h2>3. La ressource</h2>

<h3>3.1. Seed de base</h3>
<p>Au lieu de remplir sa BDD de dummy data à la main, ce qui est particulièrement fastidieux, on peut la <b>seed</b>. C'est à dire la remplir de données random en exécutant la commande : </p>

<pre><code class="language-shell">$ rails db:seed</code></pre>

<p>Au préalable, tu devras préciser ce que tu vas seeder dans le fichier <code>db/seeds.rb</code>. 

<p> Seeds.rb est comme un fichier où l'on peut écrire des lignes de commande de Rails Console. Par exemple si tu écris à l'intérieur :</p>

<pre><code class="language-ruby">User.create(name: "jean", email:"jean@jean.jean")
User.create(name: "paul", email:"paul@paul.paul")
p "Deux utilisateurs ont été créés"</code></pre>
Et que tu fais :

<pre><code class="language-ruby">$ rails db:seed</code></pre>

<p>Rails va te créer 2 utilisateurs, et t'afficher qu'il a créé 2 utilisateurs.</p>

<p>Et le programme est encore plus intéressant si tu fais un truc du genre :</p>

<pre><code class="language-ruby"><code>100.times do |index|
  user = User.create!(name: "Nom#{index}", email: "email#{index}@example.com")
end</code></code></pre>

<p> Bref, tu pourras trouver des tuto pour seeds <a href="http://www.railszilla.com/rails-seed-data-example/rails" target="_blank">ici</a> et <a href="https://davidmles.com/seeding-database-rails/" target="_blank">là</a>.</p>

<div class="card box-shadow-0 border-info">
  <div class="card-content collapse show">
    <div class="card-body">
      <h4 class="card-title">🚀 ALERTE BONNE ASTUCE</h4>
      <p class="card-text">Comme tout le monde, tu vas te tromper au début et devoir relancer ton programme plusieurs fois. Avant de commencer un seed, il est généralement bien vu de remettre sa base de données à 0, pour éviter l'armée d'utilisateurs ayant le même email. Tu peux commencer ton seed par :</p>
      <pre><code class="language-ruby">Model1.destroy_all
Model2.destroy_all
etc</code></pre>
    </div>
  </div>
</div>


<h3>3.2. Seed avec Faker</h3>
<p><a href="https://github.com/stympy/faker" target="_blank">Faker</a> est une super gem qui permet de créer des faux noms à la volée. Renseigner dans le gemfile la ligne correspondante, puis après <code>bundle install</code> tu peux l'appeler dans le seed en faisant <code>require 'faker'</code>.</p>

<p>Voici un exemple de seed malin en utilisant la gem Faker : </p>
<pre><code class="language-ruby">require 'faker'
100.times do
  user = User.create!(name: Faker::Company.name, email: Faker::Internet.email)
end</code></pre>

<h2>4. Points importants à retenir</h2>
<p>La fichier <code>db/seeds.rb</code> permet de mettre des lignes de code qui vont te faire remplir ta base de données. Une fois que ton seed est bon, tu n'as qu'à faire <code>$ rails db:seed</code>.</p>

<p><a href="https://github.com/stympy/faker" target="_blank">Faker</a> est une super gem qui permet de créer des faux noms à la volée.</p>

          </div>
        </div>
        </div>
      </div>
    </div>
  </div>
</div>


  <div class="container">
  <div class="row">
    <div class="col-12">
      <div class="card">
        <div class="card-header" style="border-top: 3px solid #FF4081 " >
          <h1>Projet : Faire ses premières bases de données en Rails</h1>
          <a class="heading-elements-toggle">
          <i class="la la-ellipsis-v font-medium-3"></i>
          </a>
          <div class="heading-elements">
            <ul class="list-inline mb-0">
              <li><a data-action="collapse"><i class="ft-minus"></i></a></li>
              <li><a data-action="expand"><i class="ft-maximize"></i></a></li>
            </ul>
          </div> 
      </div>
      <div class="card-content collapse show">
        <div class="card-body">
          <div class="tab-pane active" id="home1" role="tabpanel">
          <h2>1. Introduction</h2>

<p>Pour ce projet, on va transcrire les exercices de design de BDD d'hier vers Rails et ActiveRecord. En gros, pour chaque start-up que nous avions imaginé, nous allons te demander de créer une application Rails puis de paramétrer les models et associations pour que leur base de données soit fonctionnelle.</p>

<p>Dans un premier temps, on va prendre l'exemple du blog pour te guider dans la création d'une base de données Rails. Ensuite, on va suivre la méthodologie classique chez THP : on te laisse la main et tu dois répliquer ce que tu as vu, en t'appuyant si nécessaire sur l'aide de tes pairs.</p>

<h2>2. Le projet</h2>

<h3>2.1. Notre petit blog des familles</h3>

<h4>2.1.1. Un tableau, de la réflexion</h4>
<p>Depuis hier, et ta première ébauche de blog, tu n'as toujours pas vu passer d'article Medium parlant de ton concept révolutionnaire. Du coup tu décides de repartir d'une feuille blanche : tu fais le choix de revoir ton blog pour qu'il propose des fonctionnalités légèrement différentes de la précédente.<br>
Le concept version 2 est le suivant: c'est un super blog où les utilisateurs pourront s'enregistrer, créer des articles, les commenter (sans pouvoir commenter les commentaires), attribuer <b>une</b> catégorie à chaque article et même les liker. Mindblowing 🤯</p>

<p>Dans cette première étape, prends ta feuille / ton tableau / ton ERD et réfléchis en équipe à l'organisation de ta base de données. Imagine tous les modèles qu'il faut pour le blog, les relations entre eux et évidemment les attributs de chacun. On est dans une mise en situation typique d'un lancement de produit : il faut concevoir en premier l'architecture de sa base de données 😇</p>

<p>Évidemment, Jean-Michel Petit-malin va te dire "t'emmerde pas, y a un pas à pas juste après !". Certes. Après, les architectures de base de données, c'est un peu comme la voiture : c'est pas en lisant le code que t'apprends à en faire (code de la route / code informatique. Vous l'avez ? 👊) Il faut pratique !! Au début ça va te paraître insurmontable, on est super fébrile, on se dit qu'on y arrivera pas. Mais très vite, on prend le pli, on devient plus serein, et on se met à faire des trucs vraiment stylés. Donc tu peux regarder <a href="https://www.youtube.com/watch?v=OnEcAcVPXUw" target="_blank" class="text-primary">TAXI</a> en boucle, c'est pas ça qui t'apprendra à faire des <i>drifts</i> de ouf. I'm out. ✋🎤</p>


<h4>2.1.2. Une app Rails, et ses models</h4>
<p>Maintenant que tu as pu réfléchir par toi-même, on va passer à la pratique en construisant ensemble l'app Rails de blog avec ses models et ses associations.</p>

<h5>a) Les bases</h5>
<p>Commence par créer une application Rails, puis mets les bonnes versions de Ruby et Rails dans le Gemfile.</p>

<h5>b) Les users</h5>
<p>Crée un modèle <code>User</code>, lié à une table qui aura comme attributs :</p>
<ul>
  <li>Un <code>first_name</code>, qui est un string</li>
  <li>Un <code>last_name</code>, qui est un string</li>
  <li>Un <code>email</code>, qui est un string</li>
</ul>

<p>Après avoir fait ta migration, va dans la console et amuse-toi à :</p>
<ul>
  <li>Créer des utilisateurs</li>
  <li>Les sauver en BDD</li>
  <li>Changer leurs <code>first_name</code>, <code>last_name</code></li>
  <li>Récupérer certains users avec <code>User.all</code>, <code>User.first</code>, <code>User.last</code> ou <code>User.find(xxx)</code></li>
</ul> 
<p>Bien maîtriser la console est <b>indispensable</b> pour bien comprendre les models et BDD en Rails : donc fais-le ! <br>
Ensuite, crée avec le seed 10 utilisateurs.</p>

<h5>c) Les articles</h5>
<p>Ajoute un model d'article. <br>
Un article a forcément un auteur (qui est un user) et un user peut avoir écrit plusieurs articles. Chaque article aura comme attributs :</p>
<ul>
  <li>Un <code>title</code>, qui est un string</li>
  <li>Un <code>content</code>, qui est un text</li>
</ul>

<p>Pour tester si ton association marche, va en console, et essaie d'ajouter à la main des articles à tes utilisateurs. Pour ça, fais un truc du genre :</p>

<pre><code class="language-ruby">u = User.first
a = Article.new
a.user = u
u.save</code></pre>

<p>Lis-bien ce que le terminal te renvoie : en cas de <code>ROLLBACK</code> ou d'erreur, tu t'es trompé. Il faut reprendre ton modèle ou tes migrations.</p>


<div class="card box-shadow-0 border-info">
  <div class="card-content collapse show">
    <div class="card-body">
      <h4 class="card-title">🚀 ALERTE BONNE ASTUCE</h4>
      <p class="card-text">Parfois tu feras <code>Truc.create</code> et la console te fait un truc du genre :</p>
<pre><code class="language-ruby">> u.save
   (36.6ms)  BEGIN
   (24.4ms)  ROLLBACK</code></pre>

      <p>Tu peux faire <code>u.errors</code> pour que ActiveRecord te dise ce qui ne va pas.</p>
    </div>
  </div>
</div>

<p>À nouveau, fais-toi la main avec la console et crée des articles en base. C'est normal et indispensable de prendre un peu de temps pour se faire la main avec la console : on est tous passés par là et tous les devs même seniors continuent de le faire 😉</p>

<p>Finalement, crée avec le fichier seed 10 articles en base de données (forcément associés à un auteur chacun).</p>

<h5>d) Les catégories</h5>
<p>Ajoute un model de catégorie. Un article a une catégorie, et une catégorie peut concerner plusieurs articles. Voici ses attributs :</p>
<ul>
  <li>Un <code>name</code>, qui est un string</li>
</ul>

<p>Bien entendu, teste la création de catégorie en console, teste aussi la relation entre les catégories et les articles. <br>
Finalement, crée avec le seed 5 catégories, puis associe tes 10 articles à une des catégories.</p>

<h5>e) Les commentaires</h5>
<p>Maintenant nous allons mettre en place un système de commentaires. Un commentaire commentera un article, et aura un auteur (qui est un utilisateur). Un utilisateur peut créer plusieurs commentaires, et un article peut avoir plusieurs commentaires. Un commentaire aura comme attributs :</p>

<ul>
  <li>Un <code>content</code>, qui est un text.</li>
</ul>

<p>Sans surprise : teste la création de commentaires et leur bonne association aux users et articles depuis la console ! <br>
Maintenant, crée dans le seed 15 commentaires, que tu assigneras à des utilisateurs et à des articles.</p>

<h5>f) Les likes</h5>
<p>Dernière étape de l'architecture de ta BDD, nous allons maintenant faire en sorte de pouvoir liker un article. <br>
Un like concerne un article, et est fait par un likeur (qui est un utilisateur). Un utilisateur peut avoir plusieurs likes, et un article peut avoir plusieurs likes. Le like n'aura pas vraiment besoin d'attributs donc nous n'allons pas lui en donner 😎</p>

<p>On ne change pas les bonnes habitudes : tests en console puis création de 15 likes en BDD avec le seed.</p>

<div class="card box-shadow-0 border-info">
  <div class="card-content collapse show">
    <div class="card-body">
      <h4 class="card-title">🚀 ALERTE BONNE ASTUCE</h4>
      <p class="card-text">Si tu es malin, tu peux te rendre compte qu'à travers un like, on crée une sorte de lien entre un article et un utilisateur (sans qu'il s'agisse de son auteur). Ainsi un article peut avoir plusieurs <i>likeurs</i> (utilisateurs), et un utilisateur peut avoir plusieurs <i>articles likés</i> (articles). <br>
      <b>Mais, mais, mais, cela ne ressemblerait pas à une relation N-N entre articles et utilisateurs ça ?</b> Exactement chef ! 🤠 <br>
      Tu viens d'avoir une illustration de la façon dont on gère une relation N-N dans Rails : grâce à une table intermédiaire entre deux tables (la table <code>likes</code> dans notre cas), et quelques lignes d'association dans les models. C'est aussi simple que cela. Bref, nous verrons ceci plus en détails demain, mais je pense que tu as compris l'astuce 🤓</p>
    </div>
  </div>
</div>


<h5>g) Faker</h5>
<p>Allez, OKLM, puisque que t'es arrivé au bout : utilise la gem Faker pour faire en sorte que les attributs des différents models soient (vaguement) plausibles (les pétages de plomb à base de Chuck Norris Facts sont autorisés 🤪). <br>
Va donc —légèrement— modifier ton seed pour que la création de chaque entrée en BDD contienne du faker et soit plus stylay.</p>


<h3>2.2. On déroule sur nos 4 autres startups</h3>
<p>Tu te souviens de MOOCademy, The Hacking Pinterest, The Hacking News et The Hacking Class ? Eh bien en repartant du travail de conception de BDD que tu avais effectué, crée une application Rails pour chacun avec les models, tables, associations et attributs qui vont bien. <br>
Complète le tout avec des seed en Faker, teste tout bien en console et le tour est dans le sac !</p>


<h2>3. Rendu attendu</h2>
<p>Aujourd'hui, tu t'es mué en créateur prolifique de start-ups. Il faudra nous soumettre 5 liens : </p>
<ul>
  <li>Un lien GitHub pour l'app Rails du blog</li>
  <li>Un lien GitHub pour l'app Rails de MOOCademy</li>
  <li>Un lien GitHub pour l'app Rails de The Hacking Pinterest</li>
  <li>Un lien GitHub pour l'app Rails de The Hacking News</li>
  <li>Un lien GitHub pour l'app Rails de The Hacking Class</li>
</ul>
          </div>
        </div>
        </div>
      </div>
    </div>
  </div>
</div>



</div>


  </div>
</div>
    <script src="/packs/dashboard-031178fac0de4f91cbcc.js"></script>
    

    <script charset="utf-8">
      $('input[name=authenticity_token]').val($('meta[name=csrf-token]').attr('content'));
    </script>

  </body>
</html>
