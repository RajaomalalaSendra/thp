<!DOCTYPE html>
<html class="loading" lang="fr">
  <head>
    <meta charset="utf-8">
    <link rel="stylesheet" type="text/css" href="../../style/bootstrap.css">
    <title>The hacking project offline</title>
  </head>
  <body class="vertical-layout vertical-menu 2-columns  menu-expanded fixed-navbar" data-open="click" data-menu="vertical-menu" data-color="bg-gradient-x-primary-blue" data-col="2-columns">
      <nav class="navbar navbar-expand-lg navbar-dark bg-primary">
        <h1 class="navbar-brand">THE HACKING PROJECT</h1>
        <button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarColor01" aria-controls="navbarColor01" aria-expanded="false" aria-label="Toggle navigation">
          <span class="navbar-toggler-icon"></span>
        </button>

        <div class="collapse navbar-collapse" id="navbarColor01">
          <ul class="navbar-nav mr-auto">
            <li class="nav-item active">
              <a class="nav-link" href="../../">Home</a>
            </li>
            <li class="nav-item">
              <a class="nav-link" href="../../features">Features</a>
            </li>
            <li class="nav-item">
              <a class="nav-link" href="../../about">About</a>
            </li>
          </ul>
          <form class="form-inline my-2 my-lg-0">
            <input class="form-control mr-sm-2" type="text" placeholder="Search">
            <button class="btn btn-secondary my-2 my-sm-0" type="submit">Search</button>
          </form>
        </div>
      </nav>

<div class="container">
    <a type="button" class="btn btn-dark " href="../../semaine_1/">Semaine 1</a>
    <a type="button" class="btn btn-dark" href="../../semaine_2/">Semaine 2</a>
    <a type="button" class="btn btn-dark" href="../../semaine_3/">Semaine 3</a>
    <a type="button" class="btn btn-dark" href="../../semaine_4/">Semaine 4</a>
    <a type="button" class="btn btn-dark btn-lg" href="../../semaine_5/">Semaine 5</a>  
</div>

<div class="app-content content">
  <div class="content-wrapper">
    <div class="content-wrapper-before"></div>
    <div class="content-header row"></div>
    
      <div class="container">
    <div class="card">
  <div class="card-header">
    <h4 class="text-center"> Programme jour par jour</h4>
  </div>
  <div class="card-body">
    <div class="text-center">
    <a href="../../semaine_5">
      <button class="btn btn-secondary btn-outline-dark btn mr-4">
        <i class="fa fa-terminal"></i>&nbsp;&nbsp;&nbsp;Lun
      </button>
</a>    <a href="../../semaine_5/jour_2">
      <button class="btn btn-secondary btn-outline-dark btn mr-4">
        <i class="fa fa-code"></i>&nbsp;&nbsp;&nbsp;Mar
      </button>
</a>    <a href="../../semaine_5/jour_3">
      <button class="btn btn-secondary btn-outline-dark btn mr-4">
        <i class="fa fa-desktop"></i>&nbsp;&nbsp;&nbsp;Mer
      </button>
</a>    <a href="../../semaine_5/jour_4">
      <button class="btn btn-secondary btn-outline-dark btn-lg mr-4">
      <i class="fa fa-folder-open"></i>&nbsp;&nbsp;&nbsp;Jeu
      </button>
</a>    <a href="../../semaine_5/jour_5">
      <button class="btn btn-secondary btn-outline-dark btn mr-4">
      <i class="fa fa-bullhorn"></i>&nbsp;&nbsp;&nbsp;Ven
      </button>
</a>    </div>
  </div>
</div>

<div class="app-content content">
  <div class="content-wrapper">
    <div class="content-wrapper-before"></div>
    <div class="content-header row"></div>
    
      
<div class="content-body">
      <h2 class="text-center">Pimp du Gossip Project</h2>
      <h4 class="text-center">Rails intermédiaire</h4>
  <div class="row">
     <div class="col-xl-3 col-lg-6 col-md-12">
  <div class="card">
    <div class="card-content">
      <div class="card-body">
        <div class="media d-flex">
          <div class="align-self-top">
              <i class="ft-calendar icon-opacity info font-large-4"></i>
          </div>
          <div class="media-body text-right align-self-bottom mt-3">
              <span class="d-block mb-1 font-medium-1"></span>
              <h3 class="info mb-0">
                 Jour 23 / 55</h3>
          </div>
        </div>
        <div class="progress progress-sm mt-1 mb-0 box-shadow-2">
            <div class="progress-bar bg-gradient-x-info" role="progressbar" style="width: 41%" aria-valuenow="25" aria-valuemin="0" aria-valuemax="120">
            </div>
        </div>
      </div>
    </div>
  </div>
 </div>


    <div class="col-xl-3 col-lg-6 col-md-12">
  <div class="card">
    <div class="card-content">
      <div class="card-body">
        <div class="media d-flex">
          <div class="align-self-top">
            <i class="ft-heart icon-opacity danger font-large-4"></i>
          </div>
          <div class="media-body text-right align-self-bottom mt-3">
            <span class="d-block mb-1 font-medium-1">Jokers restant</span>
            <h3 class="danger mb-0">
                3
            </h3>
          </div>
        </div>
      </div>
    </div>
  </div>
</div>

    <div class="col-xl-3 col-lg-6 col-md-12">
    <div class="card">
        <div class="card-content">
            <div class="card-body">
                <div class="media d-flex">
                    <div class="align-self-top">
                        <a href="/dashboard/assignments?locale=fr">
                           <i class="ft-fast-forward icon-opacity warning font-large-4"></i>
</a>                    </div>
                    <div class="media-body text-right align-self-bottom mt-3">
                        <span class="d-block mb-1 font-medium-1">Missions</span>
                            <div class="badge border-danger danger badge-border">Pas inscrit</div>
                    </div>
                </div>
            </div>
        </div>
    </div>
</div>

  </div>
  <div class="row">
        <div class="container">
    <div class="col-xl-12 col-lg-12 col-md-12">
    <div class="card">
        <div class="card-header">
        <h1 >Rails intermédiaire
                <i class="fa fa-space-shuttle text-danger"></i>
        </h1>
        
        </div>
        <div class="card-content">
        <div class="card-body">
            <div class="card-text">
            <h2 class="text-center">Pimp du Gossip Project</h2>
            <div class="cd-horizontal-timeline loaded">
                <div class="timeline">
                <div class="events-wrapper">
                    <div class="events" style="width: 1800px;">
                    <ol>
                                <li>
                                    <a style="left:120px;" href="/dashboard/weeks/5/days/1?locale=fr">
                                        Lun
                                            <i class="fa fa-rocket text-danger" aria-hidden="true" data-toggle="tooltip" data-placement="bottom" title="Projet à rendre ce jour-là"></i>

</a>                                </li>
                                <li>
                                    <a style="left:240px;" href="/dashboard/weeks/5/days/2?locale=fr">
                                        Mar
                                            <i class="fa fa-pencil text-success" aria-hidden="true" data-toggle="tooltip" data-placement="bottom" title="Corrections cette journée là" ></i>


</a>                                </li>
                                <li>
                                    <a style="left:360px;" href="/dashboard/weeks/5/days/3?locale=fr">
                                        Mer
                                            <i class="fa fa-beer text-warning" aria-hidden="true" data-toggle="tooltip" data-placement="bottom" title="Rendez-vous pour boire un coup"></i>

</a>                                </li>
                            <li>
                                <a class="selected" style="left:480px;" data-toggle="tooltip" data-placement="top" title="Pimp du Gossip Project" href="/dashboard/weeks/5/days/4?locale=fr">
                                    Jeu
                                        <i class="fa fa-rocket text-danger" aria-hidden="true" data-toggle="tooltip" data-placement="bottom" title="Projet à rendre ce jour-là"></i>

</a>                                </li>
                                <li>
                                    <a style="left:600px;" href="/dashboard/weeks/5/days/5?locale=fr">
                                        Ven
                                            <i class="fa fa-pencil text-success" aria-hidden="true" data-toggle="tooltip" data-placement="bottom" title="Corrections cette journée là" ></i>


</a>                                </li>
                    </ol>
                </div>
                </div>
            </div>
            </div>
        </div>
        </div>
    </div>
    </div>
<div>
  </div>

  <!-- Les fameuses corrections qui n'arrivnet que les jours concernés -->


    <div class="container">
  <div class="row">
    <div class="col-12">
      <div class="card">
        <div class="card-header" style="border-top: 3px solid #5E66E5 " >
          <h1>Cours : Utilisateurs avec mots de passe</h1>
          <a class="heading-elements-toggle">
          <i class="la la-ellipsis-v font-medium-3"></i>
          </a>
          <div class="heading-elements">
            <ul class="list-inline mb-0">
              <li><a data-action="collapse"><i class="ft-minus"></i></a></li>
              <li><a data-action="expand"><i class="ft-maximize"></i></a></li>
            </ul>
          </div> 
      </div>
      <div class="card-content collapse show">
        <div class="card-body">
          <div class="tab-pane active" id="home1" role="tabpanel">
          <h2>1. Introduction</h2>
<p>Dans cette ressource, nous allons voir comment gérer les mots de passe des utilisateurs de ton app Rails. Mais en guise de préambule, on va te faire un topo de culture gé en t'expliquant comment les applications web stockent, en général, les mots de passe.</p>


<h2>2. Historique</h2>
<p>Tu trouveras ci-dessous quelques éléments d'historique sur la science des mots de passe et de leur cryptage.</p>

<h2>3. La ressource</h2>
<h3>3.1. Gestion de mots de passe dans une base de données</h3>
<p>Les mots de passe sont une donnée ultra sensible qu'il faut bien protéger au sein des bases de données. Les stocker en clair (non cryptés) dans une table, c'est pas loin d'être la pire idée du monde : si jamais tu te fais hacker et que ta base de données est révélée à la Terre entière, et bien tout le monde peut voir tous les mots de passe et se connecter en lieu et place de tes utilisateurs. Et comme un bon 80 % des gens utilisent le même mot de passe pour tous les sites web, n'importe qui pourra accéder à tous leurs comptes. Ça peut légèrement nuire à l'image de ton entreprise. <br>
Morale de l'histoire : on ne stocke <b>jamais</b> de mots de passe en clair dans une base de données.</p>

<div class="card box-shadow-0 border-info">
  <div class="card-content collapse show">
    <div class="card-body">
      <h4 class="card-title">🤓 QUESTION RÉCURRENTE</h4>
      <p class="card-text"><b>Jamy, les hacks de bases de données, ça arrive souvent ?</b><br>
        Oui, même aux meilleurs. L'un des plus connus est celui de <a href="https://en.wikipedia.org/wiki/2012_LinkedIn_hack?oldformat=true" target="_blank">LinkedIn</a> en 2012, où tous leurs mots de passe ont été égarés dans la nature. Oups.</p>
        <p>Il existe même un site nommé <a href="https://haveibeenpwned.com/" target="_blank">have i been pwned?</a> qui te dit si ton adresse e-mail apparaît dans une des bases de données hackées et publiées sur les nombreux forums de hackers. Si l'un des sites hacké a, un jour, stocké ton mot de passe en clair (les chances sont faibles), tu es dans le 💩 et t'as intérêt à vite le modifier….</p>
    </div>
  </div>
</div>

<p>Alors, comment font les sites pour stocker ton mot de passe et te permettre de l'utiliser mais sans le connaître eux-mêmes ? Généralement, ils utilisent ce que l'on appelle une fonction de hashage cryptographique. Derrière ce nom stylé (à noter et à ressortir au prochain apéro avec tes potes) se cache un programme informatique simple : il va transformer n'importe quel string en une suite de caractères du genre <code>900150983cd24fb0d6963f7d28e17f72</code>. On appelle cette suite un "hash" (attention, ça a le même nom mais c'est très différent des hash comme <code>params</code> qu'on manipule en Ruby depuis le début) et il a deux particularités importantes :</p>

<ul>
  <li>Un string ne donnera qu'un seul hash (toujours le même). Un hash identifie un seul et unique string (c’est-à-dire que si 2 strings ont le même hash, c'est qu'ils sont strictement égaux).</li>
  <li>Deux strings assez similaires, vont donner deux hash radicalement différents en sortie. Exemple :
  <ul>
    <li><code>salut</code> va donner <code>3ed7dceaf266cafef032b9d5db224717</code> 👋</li>
    <li><code>salud</code> va donner <code>6776b3dd95bba354801deda2cb769122</code> 🍻</li>
  </ul></li>
  <li>Il est très aisé de passer du <code>string</code> au <code>hash</code> mais, théoriquement, il est impossible (dans un temps raisonnable - moins de quelques dizaines d'années quoi) de passer du <code>hash</code> au <code>string</code>.</li>
</ul>

<p>Ces particularités permettent de stocker en base les hash, car même s'ils sont compromis, il sera impossible pour les hackeurs de décrypter les mots de passe qui se cachent derrière. Ainsi, tu es moins flippé de te faire hacker ta BDD : les mots de passe sont protégés. Ouf !</p>

<p>D'accord mais concrètement, comment ça fonctionne dans une application ? Nous allons stocker dans la table <code>users</code> un string nommé <code>password_digest</code>. À l'inscription, l'utilisateur va saisir son mot de passe et on va le récupérer via <code>params</code>. Ensuite on va le convertir en hash, et le stocker dans la colonne <code>password_digest</code> (le mot de passe normal est parti aux oubliettes du params). <br>
Finalement, quand il tentera de se connecter, l'utilisateur va envoyer un <code>params</code> contenant un e-mail et un mot de passe en clair. On va à nouveau convertir le mot de passe en hash et le comparer avec celui en base. Si les deux hash sont identiques, c'est que l'utilisateur t'a donné le bon mot de passe : <a href="https://www.youtube.com/watch?v=jj7BRKHml8g" target="_blank">ACCESS GRANTED</a></p>

<div class="card box-shadow-0 border-success">
  <div class="card-content collapse show">
    <div class="card-body">
      <h4 class="card-title">📚 INSTANT CULTURE GÉ</h4>
      <p class="card-text">Tu l'as donc compris : un site web digne de ce nom ne doit jamais enregistrer ton mot de passe en clair. Il ne fait que le stocker temporairement dans <code>params</code>, ce dernier étant vidé de son contenu à chaque changement de page. <br>
      Si jamais, dans ta vie d'utilisateur, tu retrouves ton mot de passe en clair d'une manière ou une autre (en URL, un e-mail qui te renvoie ton mot de passe), c'est que tu as affaire à un beau service <a href="https://www.youtube.com/watch?v=aeePeVUW6-k" target="_blank">codé avec le cul</a> et pas sécurisé. Fuis ces gens ! 🏃</p>
    </div>
  </div>
</div>


<h3>3.2. Gestion de mots de passe en Rails</h3>
<p>Il est possible de gérer les hash assez facilement dans Rails : la gem <a href="https://github.com/codahale/bcrypt-ruby" target="_blank">bcrypt</a> s'occupe de tout convertir pour toi. Pour ceci tu vas devoir faire quelques manipulations.</p>
<p>On te propose de faire quelques tests tout en suivant le cours : créé une app Rails <code>test_bcrypt</code>.</p>

<h4>3.2.1. Installer la gem</h4>
<p>Ajoute bcrypt à ton Gemfile, puis <code>bundle install</code></p>
<p><b>Astuce </b>: bcrypt est déjà dans le Gemfile, il faut juste dé-commenter la ligne. Généralement, c'est bon signe quand tu n'as que ça à faire : c'est que la gem est bien considérée comme faisant partie intégrante des fonctionnalités courantes d'une app Rails.</p>


<h4>3.2.2. Une migration pour ajouter la colonne du mot de passe</h4>
<p>Il te faut disposer d'un model <code>User</code> avec une table <code>users</code> contenant une colonne <code>password_digest</code> (c'est le hash du password - le mot de passe crypté - et c'est un string). Pour que l'exemple soit réaliste, on va aussi ajouter une colonne <code>email</code> (string). Mets cela en place avec la commande de terminal <code>$ rails g model users email:string password_digest:string</code>. Puis passe la migration pour créer la table (pense à créer ta BDD si t'es en PostGre 🙄).</p>

<p>A noter que si la table et le model existaient déjà, tu n'aurais eu qu'à faire une migration pour ajouter la colonne <code>password_digest</code> :</p>

<pre><code class="language-ruby">def change
  add_column :users, :password_digest, :string
end</code></pre>

<h4>3.2.3. Mentionner la gestion des mots de passe dans le model</h4>
<p>Dans ton model <code>User</code>, tu vas indiquer que bcrypt est en charge de gérer et hasher les mots de passe. Pour cela, rajoute la ligne : </p>

<pre><code class="language-ruby">class User < ApplicationRecord
  has_secure_password
end</code></pre>

<p>À présent, bcrypt est fonctionnel et te met à disposition les fonctionnalités suivantes :</p>
<ul>
  <li>Si tu fais <code>my_user = User.create(password: "foobar")</code>, un user va être créé et bcrypt transformera "foobar" en hash sécurisé qui sera stocké dans <code>password_digest</code>.</li>
  <li>Si tu as un objet de typer <code>User</code>, tu peux demander à bcrypt de vérifier si un string correspond à son mot de passe. Pour cela, si l'objet porte le nom <code>my_user</code>, tapes : <code>my_user.authenticate("test de mot de passe")</code>. <br>
  => Si ce mot de passe ne correspond pas à celui crypté, bcrypt te retourne <code>false</code> <br>
  => S’il correspond, bcrypt te retourne tout simplement l'objet <code>my_user</code>.</li>
  <li>Enfin, tu peux faire comme près de 100 % des sites sur Terre et demander, à l'inscription, un password et sa confirmation. Dans ce cas-là, tu peux faire <code>User.create(password: "motdepasse", password_confirmation: "laconfirmation")</code> et bcrypt n'enregistrera un utilisateur en base QUE si password et password_confirmation sont identiques. Sinon Rollback.</li>
</ul>

<p> Évidemment, tu peux aussi rajouter une contrainte sur le mot de passe, par exemple refuser qu'il soit vide ou trop court. Pour rappel, c'est simple à implémenter avec la ligne suivante dans le model <code>User</code> : <code>validates :password, presence: true, length: { minimum: 6 }</code>.</p>

<h4>3.2.4. Tests en console</h4>
<p>Ton model est prêt, et tu n'auras plus qu'à brancher les bonnes méthodes de controller. Testons ceci en console :</p>

<pre><code class="language-ruby">>> u = User.create(email: "email@example.com", password: "foobar")
=> #&lt;User id: 1, email: "email@example.com", password_digest: "$2a$10$T2/g3aj1LS6KUBZts69Yaeeq62oijKnL0VXtsL0Jd5S...", <br> created_at: "2019-02-05 14:31:30", updated_at: "2019-02-05 14:31:30">

>> my_user = User.find_by(email: "email@example.com")
>> my_user.password
=> nil

>> my_user.password_digest
=> "$2a$10$2a$10$T2/g3aj1LS6KUBZts69Yaeeq62oijKnL0VXtsL0Jd5S"

>> my_user.authenticate("not_the_right_password")
false
>> my_user.authenticate("foobaz")
false

>> my_user.authenticate("foobar")
=> #&lt;User id: 1, email: "email@example.com", created_at: "2016-05-23 20:36:46", updated_at: "2016-05-23 20:36:46", <br> password_digest: "$2a$10$xxucoRlMp06RLJSfWpZ8hO8Dt9AZXlGRi3usP3njQg3..."></code></pre>

<h4>3.2.5. Quels impacts sur une app Rails ?</h4>
<p>Ces points seront mis en pratique plus tard, mais on t'en parle dès à présent.</p>
<h5>a) Pour créer un utilisateur</h5>
<p>Par rapport à ce qu'on a vu jusque-là, la méthode <code>#create</code> du controller <code>users</code> ne change quasiment pas. Simplement, il faut récupérer le mot de passe depuis le formulaire d'inscription (via <code>params</code>) et faire un simple <code>User.new(email: "xxx", password: "yyy")</code>. La gem bcrypt s'occupe de tout côté model pour encrypter le password : Fat model, skinny controller !</p>

<h5>b) Pour qu'un utilisateur se connecte</h5>
<p>Il faut mettre en place un formulaire de connexion (e-mail + mot de passe), en récupérer les infos (via <code>params</code>) et utiliser dans le controller les méthodes <code>.find_by(email: xx)</code> (pour identifier l'utilisateur d'après son e-mail) et <code>.authenticate(xxxx)</code> (pour vérifier si le mot de passe correspond). Reporte-toi à l'exemple de la console ci-dessus si nécessaire.</p>
<p>Si on trouve bien un utilisateur à cet e-mail et que le mot de passe correspond, on peut le laisser se connecter en ouvrant une session avec <code>session[:user_id] = my_user.id</code>. Reporte-toi à la ressource sur les sessions pour en savoir plus.</p>


<h2>4. Points importants à retenir</h2>
<p>Il ne faut <b>jamais</b> stocker un mot de passe en clair, mais dans un hash sécurisé.</p>
<p>Sur Rails, la gem bcrypt s'occupe de produire le hash. Tu n'as qu'à l'installer puis faire les étapes suivantes :</p>

<ul>
  <li>Faire une migration pour ajouter à <code>users</code> une colonne <code>password_digest</code> qui est un string</li>
  <li>Ajouter la ligne <code>has_secure_password</code> dans le model des utilisateurs</li>
  <li>Éventuellement faire une validation pour le <code>password</code> avec presence true et minimum de caractère fixé à 6 (ce que proposent tous les sites sérieux)</li>
</ul>

<p>C'est tout 😎. A partir de là, bcrypt s'occupe de crypter les mots de passe dans <code>password_digest</code>.</p>
<p>Tu peux alors jouer avec des <code>my_user = User.create(password: "foobar")</code>, des <code>my_user.authenticate("test de mot de passe")</code> ou encore des <code>User.create(password: "motdepasse", password_confirmation: "laconfirmation")</code>.</p>

<h2>5. Pour aller plus loin</h2>

<p>Pour compléter notre explication sur les mots de passe, je te propose deux vidéos de <a href="https://www.youtube.com/channel/UC9-y-6csu5WGm29I7JiwpnA" target="_blank">ComputerPhile</a> sur les gestions de mots de passe :

<ul>
  <li><a href="https://www.youtube.com/watch?v=8ZtInClXe1Q" target="_blank">Comment stocker ses mots de passe</a></li>
  <li><a href="https://www.youtube.com/watch?v=7U-RbOKanYs" target="_blank">Comment hacker des mots de passe</a></li>
</ul>
          </div>
        </div>
        </div>
      </div>
    </div>
  </div>
</div>

  <div class="container">
  <div class="row">
    <div class="col-12">
      <div class="card">
        <div class="card-header" style="border-top: 3px solid #5E66E5 " >
          <h1>Cours : Créer des sessions et ses propres helpers</h1>
          <a class="heading-elements-toggle">
          <i class="la la-ellipsis-v font-medium-3"></i>
          </a>
          <div class="heading-elements">
            <ul class="list-inline mb-0">
              <li><a data-action="collapse"><i class="ft-minus"></i></a></li>
              <li><a data-action="expand"><i class="ft-maximize"></i></a></li>
            </ul>
          </div> 
      </div>
      <div class="card-content collapse show">
        <div class="card-body">
          <div class="tab-pane active" id="home1" role="tabpanel">
          <h2>1. Introduction</h2>
<p>Dans cette ressource, tu vas voir comment gérer un utilisateur connecté sur ton site web. Chacune des actions qu'il entreprendra seront alors considérées comme provenant de lui : il pourra écrire des potins dont il sera directement l'auteur, modifier son profil, etc. Oh yeah !</p>

<p>L'élément central qui va permettre de gérer cela, ce sont les sessions. Nous te montrerons comment mettre en place tes propres helpers afin d'appeler facilement des méthodes que tu souhaites utiliser sur presque toutes les views. Finalement, nous te présenterons le <code>before_action</code> qui permet d'effectuer, au sein des controllers, des tâches avant même que la méthode appelée ne soit exécutée.</p>

<h2>2. Historique et contexte</h2>
<p>Ce cours va t'apprendre à implémenter toi-même une session "utilisateur connecté" sur Rails afin de stocker des informations jusqu'à déconnexion de l'utilisateur. Dans quelques jours, on te présentera, une gem (Devise) qui automatisera la mise en place des sessions utilisateurs. Mais il est toujours intéressant, pour les concepts importants comme celui-ci, de l'avoir implémenté au moins une fois soi-même avant d'apprendre la méthode raccourcie / automatisée.</p>

<h2>3. La ressource</h2>

<h3>3.1. Les sessions</h3>
<h4>3.1.1. Introduction aux sessions</h4>
<p>Quand tu vas sur Facebook, que tu te connectes, et que tu navigues sur le site, ce dernier se souvient que tu es connecté bien que tu passes de page en page. Cette magie noire est plutôt simple à mettre en place : Facebook stocke sur ton navigateur une petite information qui indiquera, à chaque chargement de page, que tu es l'utilisateur numéro XXXX. Cette information est souvent stockée sous la forme de cookies : entre aujourd'hui et demain, nous allons t'apprendre à coder toi-même un système de cookies. La première étape est de comprendre les sessions.</p>

<p>En Rails, <code>session</code> est un hash qui est stocké dans un coin du navigateur web et qui va suivre le visiteur tout au long de sa navigation. Il est grosso modo créé quand ce dernier arrive sur ton site, et est détruit quand il ferme son navigateur. À l'inverse de <code>params</code>, qui se vide de son contenu à chaque changement de page, le hash <code>session</code> conserve les informations jusqu'à fermeture du navigateur. <br>
En tant qu'application, tu peux écrire et lire à volonté sur <code>session</code>. Si par exemple tu fais <code>session[:salut] = "Message sympa"</code> dans la méthode d'un controller, tu pourras retrouver cette info dans un autre controller (par exemple avec <code>puts session[:salut]</code>). Mais l'usage le plus courant de <code>session</code> est de stocker l'<code>id</code> de l'utilisateur actuellement connecté. Ainsi, à chaque nouvelle page chargée, on pourra retrouver quel utilisateur est en train de la visualiser. Tu feras ça dans tes controllers avec les lignes suivantes :</p>

<pre><code class="language-ruby">id = session[:user_id]
@user = User.find(id) #et hop, cette variable @user est l'instance User contenant toutes les infos de l'utilisateur connecté</code></pre>

<p>Pour gérer les connexions à ton app Rails, on va gérer des "sessions" via un <code>sessions_controller</code> qui contiendra les méthodes avec <code>#new</code>, <code>#create</code>, et <code>#destroy</code>. </p>
<ul>
  <li>La création d'une session se fera au travers de la page de login où l'on demande mot de passe et email. </li>
  <li>Puis la méthode <code>#create</code> va s'occuper d'essayer d'authentifier l'utilisateur avec le couple email-mot de passe. Si ce dernier est bien authentifié, nous stockerons l'info avec <code>session[:user_id] = user.id</code>. S'il n'est pas bien authentifié, on fera un render de la page de login avec les messages d'erreur.</li>
  <li>Une fois l'utilisateur connecté, ce sera très simple de retrouver notre utilisateur grâce à <code>User.find(session[:user_id])</code> </li>
</ul>


<div class="card box-shadow-0 border-info">
  <div class="card-content collapse show">
    <div class="card-body">
      <h4 class="card-title">🚀 ALERTE BONNE ASTUCE</h4>
      <p class="card-text">Tu peux t'amuser à voir tes sessions et cookies dans Inspecteur d'éléments -> Application -> Storage -> Cookies -> Localhost:3000. Si tu supprimes le hash <code>session</code>, c'est comme si tu fermais ton navigateur !</p>
      <p>De plus, étant donné que les cookies temporaires de <code>session</code> sont automatiquement chiffrés, faire <code>User.find(session[:user_id])</code> pour récupérer un utilisateur est sécurisé. Ce n'est pas possible pour un hacker d'utiliser les informations de <code>session</code> pour usurper ton identité. Par contre, les cookies permanents sont moins sécurisés : ils sont vulnérables à une attaque au détournement de session, et nous verrons demain comment être prudent en les utilisant.</p>
    </div>
  </div>
</div>

<h4>3.1.2. sessions_controller</h4>
<p>Ici, une session n'est pas un objet en soi. Il n'existe pas de model <code>Session</code> ni d'enregistrement dans la base de donnée. En fait, on considère qu'une session est créée à l'instant où un utilisateur se connecte à son compte sur ton site web : on a alors une information dans le hash <code>session[:user_id]</code>. Si personne n'est connecté, il n'y a pas de session et <code>session[:user_id] = nil</code>.</p>

<p>Une session utilisateur pouvant être créée ou supprimée, il semble logique d'en confier la gestion à un controller à part entière. Il s'agira de <code>sessions_controller</code> et il disposera de trois méthodes :</p>

<ul>
  <li><code>#new</code> qui correspond à la page de login</li>
  <li><code>#create</code> qui effectuera l'authentification (traitement des informations saisies dans la page login et sauvegarde de l'info de l'utilisateur connecté dans <code>session</code>)</li>
  <li><code>#destroy</code> qui correspond au logout</li>
</ul>

<p>Les routes seront celles habituelles, grâce à un <code>resources :sessions, only: [:new, :create, :destroy]</code>.</p>

<h5>a) new et create</h5>
<p>La view new va juste demander l’e-mail et le mot de passe à l'utilisateur via un formulaire, ce dernier pointant vers la méthode create. </p>
<p>La méthode <code>create</code> ressemblera à ceci :</p>

<pre><code class="language-ruby">def create
  # cherche s'il existe un utilisateur en base avec l’e-mail
  user = User.find_by(email: email_dans_ton_params)

  # on vérifie si l'utilisateur existe bien ET si on arrive à l'authentifier (méthode bcrypt) avec le mot de passe 
  if user && user.authenticate(password_dans_ton_params)
    session[:user_id] = user.id
    # redirige où tu veux, avec un flash ou pas

  else
    flash.now[:danger] = 'Invalid email/password combination'
    render 'new'
  end
end</code></pre>

<h5>b) utiliser ensuite l'info de <code>session</code></h5>
<p>Grâce au <code>create</code> de <code>sessions_controller</code>, on a pu stocker l'<code>id</code> de l'utilisateur actuellement connecté. <br>
Maintenant, à partir de cet <code>id</code>, tu peux remonter à l'utilisateur pour avoir ses infos. Par exemple tu peux faire une view <code>/profile</code> qui aura comme code :</p>
<pre><code class="language-html">&lt;h2>Bienvenue &lt;%= User.find_by(id: session[:user_id]).first_name %> !&lt;/h2></code></pre>

<p>Ou alors créer un potin et le lier immédiatement à l'utilisateur connecté (qui est forcément l'auteur), en mettant dans la méthode <code>create</code> de <code>gossips_controller</code> :</p>
<pre><code class="language-ruby">def create
  @gossip = Gossip.create(gossip_params)
  @gossip.user = User.find_by(id: session[:user_id])
  if @gossip.save
    flash[:success] = "Potin bien créé !"
    redirect_to root_path
  else
    render :new
  end
end</code></pre><br>

<p>Cette façon de faire est tout à fait fonctionnelle, mais tu remarques déjà qu'on écrit plusieurs fois <code>User.find_by(id: session[:user_id])</code>. Et c'est pas très DRY de se répéter en Rails ! <br>
Nous verrons plus loin comment remplacer ce code par un simple appel à une méthode <code>current_user</code> qui fera la même chose.</p>

<h5>c) destroy</h5>
<p>Destroy permet de déconnecter l'utilisateur. Cliquer sur le bouton "Se déconnecter" revient à supprimer le contenu de <code>session[:user_id]</code>. <br>
Le lien de ton bouton "Se déconnecter" devrait ressembler à ceci :</p>

<pre><code class="language-html">&lt;%= link_to "Se déconnecter", session_path(session[:user_id]), method: :delete %></code></pre>

<p>Ce qui a pour effet d'appeler la méthode <code>#destroy</code> de ton sessions_controller. Cette méthode devrait ressembler à ceci :</p>

<pre><code class="language-ruby">def destroy
  session.delete(:user_id)
end</code></pre>


<h3>3.2. Les helpers</h3>
<h4>3.2.1. Introduction</h4>
<p>Nous allons apprendre à changer un <code>User.find_by(id: session[:user_id])</code> en un plus simple <code>current_user</code> avec deux raisons en tête :</p>

<ol>
  <li>En Rails, c'est <b>le mal</b> de faire un appel au model (= une requête SQL) dans une vue. C'est le rôle du controller ! Le moindre <code>find</code> dans la view et c'est <code>-30</code> points en test technique.</li>
  <li>En Rails on aime le code bien DRY et bien lisible. <code>current_user</code> c'est très lisible et plus court que l'autre pâté.</li>
</ol>

<p>Pour refactorer (= condenser) de cette façon notre code, nous allons passer par un helper. Les helpers se rangent dans le dossier <code>app/helpers/</code> : ils ont pour mission de créer des méthodes pour remplacer les bouts de code qu'on utilise fréquemment. Tout ce que tu as à faire, c'est de mettre dans ton controller : </p>

<pre><code class="language-ruby">class TonController < ApplicationController
  include TonHelper
end</code></pre>

<p><code>TonHelper</code> correspond au fichier <code>app/helpers/ton_helper.rb</code> qui devrait ressembler à ceci :</p>

<pre><code class="language-ruby">module TonHelper
  def some_method
    # une méthode et son code
  end
end</code></pre>

<h4>3.2.2. SessionsHelper</h4>
<p>Nous allons donc créer un helper pour les sessions des utilisateurs. Toutefois, il faut savoir qu'on va y faire appel dans quasiment TOUS les controllers et se taper un <code>include SessionsHelper</code> dans chacun d'eux, ça va vite être fastidieux. La solution, c'est de rajouter la ligne dans <code>app/controllers/application_controller.rb</code> qui est, en quelque sorte, le parent de tous les controllers. <br>
Si tu es perspicace, tu auras noté que chaque controller commence par la ligne <code>class TonController < ApplicationController</code> : en fait ils héritent tous de <code>ApplicationController</code> ! Au final, c'est un peu le controller ultime : tout ce qui est écrit dedans, tu peux considérer qu'il est écrit dans chaque controller.</p>
<p>Donc une fois la ligne rajoutée, il faut créer un fichier <code>app/helpers/sessions_helper.rb</code> et y mettre les lignes suivantes :</p>

<pre><code class="language-ruby">module SessionsHelper
   def current_user
    User.find_by(id: session[:user_id])
  end

   def log_in(user)
    session[:user_id] = user.id
  end

end</code></pre>

<p>Et voilà ! Maintenant tu peux appeler <code>current_user</code> dans n'importe quel controller ou view, et cette méthode te retournera l'instance de <code>User</code> contenant les infos de ton utilisateur connecté.</p>

<p> Tu noteras même qu'on s'est amusés à faire une méthode <code>login(user)</code>, qui nous servira à connecter facilement l'utilisateur. Ça permet de l'appeler à la page login mais aussi juste après la création d'un nouvel utilisateur (par exemple).</p>


<div class="card box-shadow-0 border-danger">
  <div class="card-content collapse show">
    <div class="card-body">
      <h4 class="card-title">⚠️ ALERTE ERREUR COMMUNE</h4>
      <p>Dans ta view, tu pourrais être tenté d'écrire direct des <code>current_user.email</code>. Mais il faut gérer les 2 cas : 1) un utilisateur est connecté et 2) personne n'est connecté. Là, si personne n'est connecté, tu auras un joli <code>undefined method `email' for nil:NilClass</code>. <br>
      Pour éviter ça, prévoit de rajouter un <code>if current_user</code>, ou même coder une méthode <code>logged_in?</code> dans le helper. Cette méthode te retournerait <code>true</code> si <code>session[:user_id]</code> est non-nil et <code>false</code> dans le cas contraire.</p>
    </div>
  </div>
</div>



<h3>3.3. Utiliser <code>before_action</code></h3>
<p>Prenons l'exemple d'une page qui ne peut être accessible QUE par un utilisateur connecté (par exemple une page en <code>/dashboard</code>). Comment mettre en place un filtre pour rejeter les personnes non connectées ? Ça c'est une mission pour le controller ! Eh bien c'est exactement le taf du controller ! Ce dernier va vérifier si l'utilisateur est login, et puis il va le rediriger vers la page de login s'il n'est pas connecté. </p> 
<p>On pourrait imaginer de faire quelque chose comme ça dans la méthode qui pointe vers <code>/dashboard</code> :</p>

<pre><code class="language-ruby">def index
unless current_user
  flash[:danger] = "Please log in."
  redirect_to new_session_path
else
  # on code quelque chose qui permet d'afficher le dashboard de l'utilisateur
end</code></pre>

<p>Sauf qu'on peut faire ça beaucoup plus proprement. La bonne façon de le présenter, c'est de faire ça dans une méthode privée <code>authenticate_user</code>, et de l'appeler EN AMONT de la méthode du controller, grâce à un callback <code>before_action</code>. Voici le résultat :</p>

<pre><code class="language-ruby">class TonController < ApplicationController
  before_action :authenticate_user, only: [:index]

  def index
    # on code quelque chose qui permet d'afficher le dashboard de l'utilisateur
  end

  private

  def authenticate_user
    unless current_user
      flash[:danger] = "Please log in."
      redirect_to new_session_path
    end
  end

end</code></pre>

<p>Grâce à ce magnifique callback, à chaque fois que la méthode index de ton controller est appelée, la méthode <code>authenticate_user</code> va être exécutée en amont. Elle filtrera les utilisateurs non connectés pour les rediriger vers la page login : en quelques lignes tu viens de sécuriser ton application !</p>

<h2>4. Points importants à retenir</h2>
<p>Tu peux stocker des informations au sein du hash <code>session</code>. Son contenu est conservé jusqu'à fermeture du navigateur.</p>
<p>Pour gérer la connexion / déconnexion des utilisateurs à leur compte, il faut créer un controller <code>sessions_controller</code> contenant les méthodes <code>#new</code>, <code>#create</code> et <code>#destroy</code>.</p>
<p>Ces méthodes vont permettre de stocker l'<code>id</code> de l'utilisateur connecté dans <code>session[:user_id]</code></p>
<p>Les helpers se rangent dans le dossier <code>app/helpers/</code> : ils ont pour mission de créer des méthodes pour remplacer les bouts de code qu'on utilise fréquemment. Par exemple, le fait de récupérer l'identité de l'utilisateur connecté avec <code>current_user</code>.</p>
<p>Les helpers utilisés dans de nombreux controllers peuvent être rajoutés à <code>ApplicationController</code> via un <code>include TonHelper</code>. </p>
<p>Le callback <code>before_action :authenticate_user, only: [:index]</code> permet d'exécuter la méthode <code>authenticate_user</code> AVANT une méthode du controller (ici la méthode <code>index</code>). </p>

<h2>5. Pour aller plus loin</h2>
<p>Nous verrons demain comment faire les cookies permanents.</p>
          </div>
        </div>
        </div>
      </div>
    </div>
  </div>
</div>

  <div class="container">
  <div class="row">
    <div class="col-12">
      <div class="card">
        <div class="card-header" style="border-top: 3px solid #5E66E5 " >
          <h1>Cours : Les tests d&#39;intégration</h1>
          <a class="heading-elements-toggle">
          <i class="la la-ellipsis-v font-medium-3"></i>
          </a>
          <div class="heading-elements">
            <ul class="list-inline mb-0">
              <li><a data-action="collapse"><i class="ft-minus"></i></a></li>
              <li><a data-action="expand"><i class="ft-maximize"></i></a></li>
            </ul>
          </div> 
      </div>
      <div class="card-content collapse show">
        <div class="card-body">
          <div class="tab-pane active" id="home1" role="tabpanel">
          <h2>1. Introduction</h2>
<p>Jusqu'à présent, tu as vu les tests unitaires, c'est à dire les tests des éléments de ton application. Tu as vu comment faire des models solides et tester ces models. Tu as vu comment faire des vues et pouvoir les tester.</p>

<p>Les tests d'intégration permettent de tester une <i>user story</i>, c'est à dire un parcours utilisateur. En gros ils permettent de vérifier que les bouts de ton application son bien imbriqués entre eux.</p>

<h2>2. Historique</h2>
<p>Toute application en Rails qui se respecte a deux types de tests :</p>

<ul>
	<li>Les tests unitaires, que tu as vus</li>
	<li>Les tests d'intégration, que tu vas voir aujourd'hui</li>
</ul>

<h2>3. La ressource</h2>
<h3>3.1. Tests unitaires vs. tests d'intagration</h3>
<p>Les tests unitaires permettent de tester des parties bien précises de ton application : la méthode <code>x</code> du controller <code>n</code>, la view <code>new.html.erb</code> de telle ressource, ou encore les models. Ils permettent de connaître de manière chirurgicale les endroits où ton application va planter (tel controller n'a pas redirigé l'utilisateur vers la page d'accueil car tu l'as mal paramétré).</p>

<p>Les tests d'intégration vont tester ton application haut-niveau, c'est à dire ils vont simuler un utilisateur qui se balade sur ton application et qui fait ce que tes utilisateurs vont faire : s'inscrire, se connecter, s'enregistrer à une session, etc. Par exemple, pour tester le <i>signup</i>, nous allons tester un visiteur qui va sur le site, qui clique sur "S'inscire", qui remplit le formulaire, qui clique sur envoyer, puis qui est redirigé vers la page post inscription (un dashboard, ou une vue profil par exemple).</p>

<p>Les tests unitaires et les tests d'intégration ont chacun leurs avantages et leur défauts. Une application bien testée aura les deux types de tests.</p>

<p>Pour mieux te renseigner sur les avantages et défauts de chacun des tests, permets-moi de te proposer <a href="https://www.youtube.com/watch?v=vqAaMVoKz1c" target="_blank">cette vidéo</a> de Mattias Petter Johansson qui explique à merveille la différence et l'importance des deux types de tests.</p>

<h3>3.2. Les tests d'intégration en Rails</h3>
<h4>3.2.1. Rspec, Capybara</h4>
<p>Pour Rspec, les tests d'intégration vont se faire dans le dossier <code>spec/features/ce_que_tu_veux_faire.rb</code>. Voici quelques exemples de tests d'intégration importants :</p>

<ul>
	<li>Un test pour l'inscription à ton site
	<ul>
		<li>Une inscription qui réussit</li>
		<li>Mais aussi une qui rate (le site doit renvoyer une erreur et dire que l'email est déjà pris / il manque le champ mot de passe / autre)</li>
	</ul></li>
	<li>Un test pour le login à ton site
	<li>Tester la fonctionnalité principale ou Happy Path de ton application : faire une réservation sur Doctolib, commander une voiture sur Uber, regarder un film su Netflix</li>
	<li>Tester une fonctionnalité plus précise, mais toute aussi importante : pouvoir annuler une réservation sur Doctolib, pouvoir liker un post sur Facebook, avoir un écran qui affiche les bonnes recommandations sur Netflix</li>
</ul>


<p>Rails est normalement équipé d'une Gem qui permet de lancer des tests d'intégration : <a href="https://github.com/teamcapybara/capybara" target="_blank">Capybara</a>. Cette Gem permet de simuler très rapidement une page Rails (sans JavaScript) pour tester qu'il est possible de s'enregistrer etc. C'est une version plus rapide à s'exécuter que Watir. Vérifie bien que tu as Capybara dans le groupe de tests de Rails, et ajoute la Gem si ce n'est pas le cas.</p>

<h4>3.2.2. Des exemples de tests d'intégration en Rails</h4>
<p>Voici un exemple simple de test d'intagration en Rspec qui teste que le signup marche bien :</p>

<pre><code class="language-ruby">describe "the signup process", type: :feature do
  before :each do
    User.make(email: 'user@example.com', password: 'password')
  end

  it "signs me in" do
    # on va sur la page de création d'utilisateurs
    visit '/users/new'

    # dans le formulaire des users, on remplit les données qu'il faut
    within("#user") do
      fill_in 'Email', with: 'user@example.com'
      fill_in 'Password', with: 'password'
    end

    # clik clik
    click_button 'Sign in'

    # la page affichée devrait afficher des bonnes nouvelles
    expect(page).to have_content 'Success'
  end
end</code></pre>


<p>Enfin, voici des ressources pour avoir quelques exemples de bonnes pratiques pour les tests d'intégration :</p>

<ul>
	<li>As usual, ThoughBot sont les champions, <a href="https://thoughtbot.com/blog/rspec-integration-tests-with-capybara" target="_blank">voici un article au sujet des tests d'intégration de leur part</a></li>
	<li>La documentation officielle <a href="https://relishapp.com/rspec/rspec-rails/docs/feature-specs/feature-spec" target="_blank">peut aussi bien t'aider</a></li>
	<li>Rob Race a écrit <a href="https://hackernoon.com/your-guide-to-testing-in-ruby-on-rails-5-c8bd122e38ad" target="_blank">un article sur les tests</a> sur HackerNoon</li>
</ul>

<h2>4. Points importants à retenir</h2>
<p>Une application bien testée doit avoir des tests d'intégration (qui testent les parcours utilisateurs) et des tests unitaires (qui testent de manière très précises les parties importantes de ton application).</p>

<p>Si ton application devait ne contenir que 4 tests, les voici :</p>

<ul>
	<li>Un test d'intégration de ton happy path</li>
	<li>Un test unitaire de la méthode de controller importante pour ton happy path (<code>appointments#create</code> pour les RDV médicaux de Doctolib, etc)</li>
	<li>Des tests unitaires pour que le model important marchent bien (User, Appoi)</li>
	<li>La view concernée par le happy path</li>
</ul>



<h2>5. Pour aller plus loin</h2>
<p>RàS pour le moment.</p>

          </div>
        </div>
        </div>
      </div>
    </div>
  </div>
</div>


  <div class="container">
  <div class="row">
    <div class="col-12">
      <div class="card">
        <div class="card-header" style="border-top: 3px solid #FF4081 " >
          <h1>Projet : Gossip Project : Facebook style</h1>
          <a class="heading-elements-toggle">
          <i class="la la-ellipsis-v font-medium-3"></i>
          </a>
          <div class="heading-elements">
            <ul class="list-inline mb-0">
              <li><a data-action="collapse"><i class="ft-minus"></i></a></li>
              <li><a data-action="expand"><i class="ft-maximize"></i></a></li>
            </ul>
          </div> 
      </div>
      <div class="card-content collapse show">
        <div class="card-body">
          <div class="tab-pane active" id="home1" role="tabpanel">
          <h2>1. Introduction</h2>
<p>Ça y est ! Tu commences à maîtriser les fondamentaux de Rails, les termes de MVC, routes, params et bases de données te sont familiers et tu commences à être fier des quelques applications que tu as mis en production cette semaine.</p>

<p>Aujourd'hui, nous allons un peu plus loin avec notre application Gossip Project, en rajoutant des features un peu plus stylées que tu pourras peut-être réutiliser pour l'architecture de ton projet final.</p>
<p>Pour commencer, tu peux reprendre ton app d'hier car la base de données reste globalement la même.</p>

<p>Ce projet sera peu guidé, je vais juste te donner une liste de fonctionnalités que ton app devra avoir et tu vas les implémenter. Celles-ci reprendrons essentiellement ce que tu as vu cette semaine et la semaine dernière.</p>

<p>Voici ce que tu vas devoir implémenter dans l'application :</p>

<ul>
	<li>Nous allons commencer par un CRUD succinct des utilisateurs : création</li>
	<li>Nous allons mettre en place un système de login / logout avec une page de connexion</li>
	<li>Nous allons faire en sorte que les potins créés soient associés à l'utilisateur en cours, idem pour les commentaires</li>
	<li>Nous allons rendre impossible la création de potin si l'utilisateur n'est pas connecté. Idem pour <code>show</code> du potin</li>
	<li>Édition et destruction des potins</li>
	<li>Puis nous allons mettre en place le système de likes</li>
</ul>


<h2>2. Le projet</h2>

<h3>2.1. Création d'utilisateurs</h3>
<p>Fais donc une création d'utilisateur, avec la notion de mot de passe. Bien entendu, le mot de passe ne sera pas stocké en clair dans ta base de données.</p>

<p>Le lien pour s'inscrire devra être sur la navbar. Et une fois l'utilisateur inscrit l'utilisateur sera redirigé vers la page d'accueil.</p>

<h3>2.2. Login / logout</h3>
<h4>2.2.1. Login</h4>
<p>Nous allons mettre un écran de connexion à l'application qui demandera email et mot de passe. Cet écran va créer une session si tu arrives à authentifier l'utilisateur avec l'email ou le mot de passe, puis le rediriger vers la page d'accueil s'il arrive à se connecter. Cela sera relié au <code>sessions_controller</code> (méthodes <code>#new</code> et <code>#create</code>)</p>

<p>Aussi, à la création de l'utilisateur, il faut login l'utilisateur.</p>

<h4>2.2.2. Logout</h4>
<p>Maintenant il faut faire <code>sessions#destroy</code>. Code la méthode.</p>


<h4>2.2.3. Login / Signup</h4>
<p>Dans la majorité des sites (le notre inclus), tu pourras retrouver en haut à droite un bouton qui change en fonction de l'état de l'utilisateur

<ul>
	<li>Si l'utilisateur n'est pas connecté, il y aura un  <a href="https://getbootstrap.com/docs/4.0/components/dropdowns/" target="_blank">dropdown</a> "S'inscrire / Se connecter", avec un bouton pour lien (<code>users#new</code>) et un lien pour se connecter (<code>sessions#new</code>)</li>
	<li>Si l'utilisateur est connecté, il y aura un bouton pour se déconnecter (<code>sessions#destroy</code>)</li>
</ul>

<p>Ta mission est mettre en place ceci.</p>

<h3>2.3. Création des potins</h3>
<p>Quand tu créés un potin, ce dernier est associé à un utilisateur de ta base. Arrange-toi pour faire en sorte que le potin créé soit associé à l'utilisateur connecté. Fais de même avec les commentaires.</p>

<h3>2.4. Impossible de commérer sans inscription</h3>
<p>Si actuellement tu crées un potin alors que le visiteur n'est pas connecté, cela va te renvoyer un bug. C'est pas incroyable. Il faut donc faire en sorte que les méthodes <code>#new</code> et <code>#create</code> vérifient que l'utilisateur est bien connecté avant de se lancer. Si ce dernier n'est pas connecté, l'application devra le renvoyer vers l'écran de login. Fais la même pour l'affichage du potin, et la création de commentaires.</p>



<p>indice : <code>before_action</code></p>



<h3>2.5. Édition et destruction des potins</h3>
<p>Pour le moment, tout le monde peut éditer un potin. Arrange-toi pour que le bouton pour pouvoir éditer le potin n'apparaisse QUE si l'utilisateur connecté est le créateur du potin. De plus, les méthodes <code>gossips#edit</code>, <code>gossips#update</code> et <code>gossips#destroy</code> doivent vérifier que le current_user soit bien le créateur du potin : impossible de faire ces actions (afficher le formulaire d'édition du potin, pouvoir éditer le potin, pouvoir détruire le potin) si ce n'est pas le créateur qui le fait !</p>


<h3>2.6. Like that</h3>
<p>Nous allons mettre en place un système de likes, yahou ! Il faut que l'on soit capable de liker un potin sur la page d'index des potins, sur la page des villes (qui affiche les potins pour une ville donnée), ainsi que sur la page d'affichage d'un potin.</p>

<p>Le like sera attribué à l'utilisateur en cours (comme Facebook) donc il est impossible de liker si le visiteur n'est pas connecté. Enfin, sur les pages mentionnées plus haut, insère aussi un petit espace qui dit le nombre de likes d'un potin.</p>

<p>Pour finir : il est possible de déliker un potin.</p>


<h2>3.Rendu attendu</h2>
<p>Un gossip project qui déchire !</p>

<p>⚠ il est <b>interdit</b> d'utiliser une gem d'authentification comme Devise ou Clearance. Seule bcrypt est autorisée.</p>
          </div>
        </div>
        </div>
      </div>
    </div>
  </div>
</div>



</div>


  </div>
</div>
    <script src="/packs/dashboard-031178fac0de4f91cbcc.js"></script>
    

    <script charset="utf-8">
      $('input[name=authenticity_token]').val($('meta[name=csrf-token]').attr('content'));
    </script>

  </body>
</html>
