<!DOCTYPE html>
<html class="loading" lang="fr">
  <head>
    <meta charset="utf-8">
    <link rel="stylesheet" type="text/css" href="../style/bootstrap.css">
    <title>The hacking project offline</title>
  </head>
  <body class="vertical-layout vertical-menu 2-columns  menu-expanded fixed-navbar" data-open="click" data-menu="vertical-menu" data-color="bg-gradient-x-primary-blue" data-col="2-columns">
      <nav class="navbar navbar-expand-lg navbar-dark bg-primary">
        <h1 class="navbar-brand">THE HACKING PROJECT</h1>
        <button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarColor01" aria-controls="navbarColor01" aria-expanded="false" aria-label="Toggle navigation">
          <span class="navbar-toggler-icon"></span>
        </button>

        <div class="collapse navbar-collapse" id="navbarColor01">
          <ul class="navbar-nav mr-auto">
            <li class="nav-item active">
              <a class="nav-link" href="../">Home</a>
            </li>
            <li class="nav-item">
              <a class="nav-link" href="../features">Features</a>
            </li>
            <li class="nav-item">
              <a class="nav-link" href="../about">About</a>
            </li>
          </ul>
          <form class="form-inline my-2 my-lg-0">
            <input class="form-control mr-sm-2" type="text" placeholder="Search">
            <button class="btn btn-secondary my-2 my-sm-0" type="submit">Search</button>
          </form>
        </div>
      </nav>

<div class="container">
    <a type="button" class="btn btn-dark" href="../semaine_1/">Semaine 1</a>
    <a type="button" class="btn btn-dark" href="../semaine_2/">Semaine 2</a>
    <a type="button" class="btn btn-dark btn-lg" href="../semaine_3/">Semaine 3</a>
    <a type="button" class="btn btn-dark" href="../semaine_4/">Semaine 4</a>
    <a type="button" class="btn btn-dark" href="../semaine_5/">Semaine 5</a>  
</div>

<div class="app-content content">
  <div class="content-wrapper">
    <div class="content-wrapper-before"></div>
    <div class="content-header row"></div>
    
      <div class="container">
    <div class="card">
  <div class="card-header">
    <h4 class="text-center"> Programme jour par jour</h4>
  </div>
  <div class="card-body">
    <div class="text-center">
    <a href="../semaine_3">
      <button class="btn btn-secondary btn-outline-dark btn-lg mr-4">
        <i class="fa fa-terminal"></i>&nbsp;&nbsp;&nbsp;Lun
      </button>
</a>    <a href="../semaine_3/jour_2">
      <button class="btn btn-secondary btn-outline-dark btn mr-4">
        <i class="fa fa-code"></i>&nbsp;&nbsp;&nbsp;Mar
      </button>
</a>    <a href="../semaine_3/jour_3">
      <button class="btn btn-secondary btn-outline-dark btn mr-4">
        <i class="fa fa-desktop"></i>&nbsp;&nbsp;&nbsp;Mer
      </button>
</a>    <a href="../semaine_3/jour_4">
      <button class="btn btn-secondary btn-outline-dark btn mr-4">
      <i class="fa fa-folder-open"></i>&nbsp;&nbsp;&nbsp;Jeu
      </button>
</a>    <a href="../semaine_3/jour_5">
      <button class="btn btn-secondary btn-outline-dark btn mr-4">
      <i class="fa fa-bullhorn"></i>&nbsp;&nbsp;&nbsp;Ven
      </button>
</a>    </div>
  </div>
</div>

<div class="app-content content">
  <div class="content-wrapper">
    <div class="content-wrapper-before"></div>
    <div class="content-header row"></div>
    
      
<div class="content-body">
      <h2 class="text-center">Découverte de la POO</h2>
      <h4 class="text-center">Programmation Orientée Objet</h4>
  <div class="row">
     <div class="col-xl-3 col-lg-6 col-md-12">
  <div class="card">
    <div class="card-content">
      <div class="card-body">
        <div class="media d-flex">
          <div class="align-self-top">
              <i class="ft-calendar icon-opacity info font-large-4"></i>
          </div>
          <div class="media-body text-right align-self-bottom mt-3">
              <span class="d-block mb-1 font-medium-1"></span>
              <h3 class="info mb-0">
                 Jour 24 / 55</h3>
          </div>
        </div>
        <div class="progress progress-sm mt-1 mb-0 box-shadow-2">
            <div class="progress-bar bg-gradient-x-info" role="progressbar" style="width: 43%" aria-valuenow="25" aria-valuemin="0" aria-valuemax="120">
            </div>
        </div>
      </div>
    </div>
  </div>
 </div>


    <div class="col-xl-3 col-lg-6 col-md-12">
  <div class="card">
    <div class="card-content">
      <div class="card-body">
        <div class="media d-flex">
          <div class="align-self-top">
            <i class="ft-heart icon-opacity danger font-large-4"></i>
          </div>
          <div class="media-body text-right align-self-bottom mt-3">
            <span class="d-block mb-1 font-medium-1">Jokers restant</span>
            <h3 class="danger mb-0">
                3
            </h3>
          </div>
        </div>
      </div>
    </div>
  </div>
</div>

    <div class="col-xl-3 col-lg-6 col-md-12">
    <div class="card">
        <div class="card-content">
            <div class="card-body">
                <div class="media d-flex">
                    <div class="align-self-top">
                        <a href="/dashboard/assignments?locale=fr">
                           <i class="ft-fast-forward icon-opacity warning font-large-4"></i>
</a>                    </div>
                    <div class="media-body text-right align-self-bottom mt-3">
                        <span class="d-block mb-1 font-medium-1">Missions</span>
                            <div class="badge border-danger danger badge-border">Pas inscrit</div>
                    </div>
                </div>
            </div>
        </div>
    </div>
</div>

  </div>
  <div class="row">
        <div class="container">
    <div class="col-xl-12 col-lg-12 col-md-12">
    <div class="card">
        <div class="card-header">
        <h1 >Programmation Orientée Objet
                <i class="fa fa-beer text-warning"></i>
        </h1>
        
        </div>
        <div class="card-content">
        <div class="card-body">
            <div class="card-text">
            <h2 class="text-center">Découverte de la POO</h2>
            <div class="cd-horizontal-timeline loaded">
                <div class="timeline">
                <div class="events-wrapper">
                    <div class="events" style="width: 1800px;">
                    <ol>
                            <li>
                                <a class="selected" style="left:120px;" data-toggle="tooltip" data-placement="top" title="Découverte de la POO" href="/dashboard/weeks/3/days/1?locale=fr">
                                    Lun
                                        <i class="fa fa-beer text-warning" aria-hidden="true" data-toggle="tooltip" data-placement="bottom" title="Rendez-vous pour boire un coup"></i>

</a>                                </li>
                                <li>
                                    <a style="left:240px;" href="/dashboard/weeks/3/days/2?locale=fr">
                                        Mar
                                            <i class="fa fa-rocket text-danger" aria-hidden="true" data-toggle="tooltip" data-placement="bottom" title="Projet à rendre ce jour-là"></i>

</a>                                </li>
                                <li>
                                    <a style="left:360px;" href="/dashboard/weeks/3/days/3?locale=fr">
                                        Mer
                                            <i class="fa fa-pencil text-success" aria-hidden="true" data-toggle="tooltip" data-placement="bottom" title="Corrections cette journée là" ></i>


</a>                                </li>
                                <li>
                                    <a style="left:480px;" href="/dashboard/weeks/3/days/4?locale=fr">
                                        Jeu
                                            <i class="fa fa-rocket text-danger" aria-hidden="true" data-toggle="tooltip" data-placement="bottom" title="Projet à rendre ce jour-là"></i>

</a>                                </li>
                                <li>
                                    <a style="left:600px;" href="/dashboard/weeks/3/days/5?locale=fr">
                                        Ven
                                            <i class="fa fa-pencil text-success" aria-hidden="true" data-toggle="tooltip" data-placement="bottom" title="Corrections cette journée là" ></i>


</a>                                </li>
                    </ol>
                </div>
                </div>
            </div>
            </div>
        </div>
        </div>
    </div>
    </div>
<div>
  </div>

  <!-- Les fameuses corrections qui n'arrivnet que les jours concernés -->


    <div class="container">
  <div class="row">
    <div class="col-12">
      <div class="card">
        <div class="card-header" style="border-top: 3px solid #5E66E5 " >
          <h1>Cours : La Programmation Orientée Objet (POO)</h1>
          <a class="heading-elements-toggle">
          <i class="la la-ellipsis-v font-medium-3"></i>
          </a>
          <div class="heading-elements">
            <ul class="list-inline mb-0">
              <li><a data-action="collapse"><i class="ft-minus"></i></a></li>
              <li><a data-action="expand"><i class="ft-maximize"></i></a></li>
            </ul>
          </div> 
      </div>
      <div class="card-content collapse show">
        <div class="card-body">
          <div class="tab-pane active" id="home1" role="tabpanel">
          								<h2>1. Introduction</h2>
<p>Ça y est, on va muscler un peu notre jeu avec la fameuse Programmation Orienté Objet (POO) dont vous avez (sûrement) vaguement entendu parler. Comme Ruby est construit selon ses principes, il est SUPER important de bien comprendre ce que c’est. En deux mots : c'est une philosophie de programmation où on manipule les données comme étant des objets auxquels sont rattachés plein de variables (qui le définissent) et de méthodes (qui le modifient ou qui lui font faire des actions). Pas de panique tout va s'éclaircir avec des exemples !</p>

<div class="card box-shadow-0 border-danger">
  <div class="card-content collapse show">
    <div class="card-body">
      <h4 class="card-title">⚠️ ALERTE ERREUR COMMUNE</h4>
      <p class="card-text">Le cours d'aujourd'hui est très dense, donc:</p>
      <ul>
        <li>Prend bien le temps de lire voir de relire plusieurs fois nos explications pour bien les comprendre.</li>
        <li>Lis et essaye de bien comprendre le code qu'on te donne en exemple. Le copier-coller sans le lire c'est passer à côté de 80 % de l'apprentissage.</li>
      </ul>
      <p>Au final, on va parler en utilisant plein de nouveaux mots et si tu lis trop vite, tu vas passer à côté des subtilités. C'est un bon investissement de ne pas te lancer trop vite … et finalement bloquer plus tard sur une notion non comprise.</p>
    </div>
  </div>
</div>

<h2>2. Historique</h2>
<p>Tout commence un matin de 1960. Ce jour-là, Ivan Sutherland, un étudiant en thèse au MIT à Boston, se réveille avec une grande idée. Il souhaite créer un logiciel qui permet de dessiner sur un ordinateur. Pour rappeler un peu le contexte, on est à une époque où la souris n'existe pas et les interfaces graphiques des ordinateurs non plus.</p>
<p>Son logiciel, SketchPad, permet, à l'aide d'un stylet, de dessiner avec l'ordinateur des formes simples comme des triangles, carrés, cercles, etc. Ce projet a posé les bases de la création assistée par ordinateur (CAO), mais aussi de la POO.</p>
<p>Pourquoi ? Eh bien parce qu'en POO, on crée des objets qui contiennent des propriétés et une logique propre. Et souvent <b>ces objets représentent des éléments concrets de la vie (rappelez-vous toujours de ça)</b> comme un utilisateur, un article ou un panier. Et dans le cas de SketchPad, Sutherland a créé des objets pour représenter un triangle, un carré, un rond, etc. Et c'est ce qui a permis à Sutherland de programmer SketchPad. Car dans son code au lieu de manipuler une variable <code>hauteur</code> et une autre variable <code>largeur</code> pour représenter un rectangle, il pouvait manipuler directement un objet rectangle dans son programme. Et faire appel à sa hauteur et sa largeur quand nécessaire.</p>
<p>Son projet en influence beaucoup d'autres et entraîne Xeros dans les années 70 (à qui on doit l'invention de la souris et de l'interface graphique) à plancher sur l'ordinateur personnel. Ils veulent créer un ordinateur que tout le monde pourrait facilement utiliser grâce à une interface graphique, une souris, des fenêtres, etc. Et pour représenter tous ces éléments à l'écran et soutenir la logique de leur affichage, une équipe emmenée par Alan Kay a créé le langage SmallTalk qui, pour beaucoup, a posé les derniers jalons de la POO telle qu'on l'utilise aujourd'hui !</p>
<p>La POO, c'est une philosophie de décomposition des programmes qui facilite la compréhension de leur agencement, de leur architecture. Elle est utilisée dans de nombreux langages comme :</p>

<ul>
  <li>Ruby (ce langage est la quintessence de l'orienté objet)</li>
  <li>Python</li>
  <li>Java</li>
  <li>C++</li>
  <li>C#</li>
</ul>

<p>En conclusion, l'orienté objet est utilisé dans la majeure partie de l'univers de la programmation, et est un élément indispensable de Ruby. Nous allons voir plus en détail tout ceci.</p>

<h2>3. La ressource</h2>
<h3>3.1. Ton premier objet</h3>
<h4>3.1.1. Définition</h4>
<p>Maintenant qu'on a introduit la POO grâce à un petit historique, tu vas te mettre à coder en créant ton premier objet Ruby. Avant ça, voici un petit exemple conceptuel pour encore mieux comprendre le principe de la programmation orientée objet.</p>


<div class="card box-shadow-0 border-success">
  <div class="card-content collapse show">
    <div class="card-body">
      <h4 class="card-title">🎨 EXEMPLE ILLUSTRÉ</h4>
      <p class="card-text">Imagine que tu as face à toi une voiture. On en a tous une représentation générale en tête : elle a 4 roues, un volant, un châssis, fonctionne grâce à une source d'énergie, etc. <strong>Ce schéma, cette représentation globale, c'est ce qu'on va appeler en code une <u>classe</u></strong>. <br>
        Et quand on voit une vraie voiture devant nous, par exemple <u>la</u> Zoé immatriculée AZ-123-PE (y en a pas 2), <strong>on a un exemplaire <u>unique</u> d'un objet appartenant à cette classe : c'est ce qu'on va appeler en code une <u>instance</u></strong>. <br> En résumé, un objet en informatique c'est comme un objet dans la vie : c'est un exemplaire (une instance) d'un type d'objet (une classe) tout comme la Zoé immatriculée AZ-123-PE est un exemplaire de voiture. <br>
        Tu peux appliquer ça à n'importe quel objet de ton quotidien : l'ordi sur lequel tu nous lis est une instance (il est unique et sans égal) de la classe "ordinateur". Ton père est une instance de la classe "homme". Ton slip est une instance de la classe "sous-vêtement". Bon je crois que tu piges.</p>
    </div>
  </div>
</div>


<h4>3.1.2. Classes et Instances</h4>
<p>À ton tour ! Tu vas définir une classe <code>User</code> et tu utiliseras <code>binding.pry</code> pour tester ton code via la console de PRY.</p>

<div class="card box-shadow-0 border-info">
  <div class="card-content collapse show">
    <div class="card-body">
      <h4 class="card-title">🚀 ALERTE RAPPEL</h4>
      <p class="card-text">PRY est une gem Ruby qui permet de tester le code dans un REPL. C'est très pratique pour afficher les valeurs que prennent tes variables dans une boucle par exemple. Si ce n'est pas déjà fait : <code>$ gem install pry</code></p>
      <p>Dans ce cours nous allons beaucoup illustrer les notions en te faisant taper du code contenant un <code>binding.pry</code> qui va lancer la console de PRY. Dans cette console tu pourras ensuite faire plein de tests pour comprendre comment les notions marchent.</p>
      <p>Rappelle toi toujours que <b>ce que tu tapes dans la console PRY peut être rédigé exactement de la même façon dans ton code et devrait te donner <u>le même résultat</u></b> (à la différence que dans PRY, il est affiché par défaut. Dans le code il faut mettre un <code>puts</code> pour que les choses s'affichent)</p>
    </div>
  </div>
</div>

<p>Pour définir une classe, tu écris dans ton code <code>class NomDeTaClasse</code> (CamelCase obligé sur les class en Ruby) que tu termines avec un <code>end</code>. À l'intérieur de cette classe tu mettras de quoi la définir. Nous allons donc faire une classe <code>User</code> où chaque instance pourra dire "Bonjour Monde !".</p>

<p>Crée un fichier Ruby: <code>$ touch user.rb</code> et écris le code suivant dedans :</p>
<pre><code class="language-ruby">require "pry"
class User
  def greet
    puts "Bonjour, monde !"
  end
end #fin de ma classe

binding.pry
puts "end of file"</code></pre>

<p>Maintenant tu vas générer des instances de cette classe avec les lignes <code>ton_instance = NomDeTaClasse.new</code>. Lance ton programme puis tape les lignes suivantes (<b>ligne par ligne !</b>) dans la fenêtre de ton PRY quand il se lance (ça fonctionnerait aussi de les rajouter dans ton code après ta classe) :</p>

<pre><code class="language-ruby">julie = User.new
jean = User.new</code></pre>

<p>Faisons aussi dire Bonjour à tes nouveaux objets ! Pour faire exécuter une méthode sur une instance, il faut faire <code>ton_instance.méthode</code>. Évidemment <code>méthode</code> doit avoir été définie dans la <code>Class</code> à laquelle <code>ton_instance</code> appartient. Tu suis ? <br> Donc exécute ton code et tape ça dans PRY pour tester :</p>

<pre><code class="language-ruby">julie.greet
jean.greet</code></pre>

<div class="card box-shadow-0 border-danger">
  <div class="card-content collapse show">
    <div class="card-body">
      <h4 class="card-title">⚠️ ALERTE ERREUR COMMUNE</h4>
      <p class="card-text">Quelques règles à savoir quand on fait de l'objet :</p>
      <ul>
        <li>Une classe s'écrit et s'appelle <b>toujours</b> en CamelCase (<code>User</code>, <code>EmailSender</code>)</li>
        <li>Une méthode et une variable s'écrivent <b>toujours</b> en snake_case (<code>send_email</code>, <code>first_name</code>)</li>
        <li>Le fichier correspondant à une classe est <b>toujours</b> la version snake_case du nom de la classe (<code>user.rb</code> pour la classe <code>User</code>, <code>email_sender.rb</code> pour la classe <code>Email</code>)</li>
      </ul>
    </div>
  </div>
</div>


<div class="card box-shadow-0 border-info">
  <div class="card-content collapse show">
    <div class="card-body">
      <h4 class="card-title">🚀 ALERTE BONNE ASTUCE</h4>
      <p class="card-text">Tu dois maintenant pouvoir facilement différencier une classe de ses instances : <code>User</code> est une classe alors que <code>julie</code> et <code>jean</code> en sont des instances. C'est pourquoi <code>User.greet</code> renvoie une erreur alors que <code>julie.greet</code> fonctionne très bien. Ne me crois pas sur parole : fais le test !<br> De même pour <code>User.new</code>qui fonctionne contrairement à <code>alice.new</code>. Tu en déduis qu'il existe des méthodes de <strong>classe</strong> et d'autres <strong>d'instances</strong>.</p>
      <p>Pour le moment c'est un peu flou, mais sache juste qu'il faut faire la différence entre une instance, et sa classe tout comme tu sais faire la différence entre une voiture que tu vois devant toi (instance) et la notion abstraite de voiture (classe) que nous avons tous en tête.</p>
    </div>
  </div>
</div>

<h3>3.2. Travailler sur une instance</h3>
<p>Maintenant que tu sais faire la différence entre une instance et une classe, nous allons travailler sur des instances. Dans cette partie tu vas voir comment :</p>

<ul>
  <li>Utiliser des <b>méthodes d'instance</b> pour que tes instances exécutent des choses bien précises (dire bonjour à quelqu'un par exemple)</li>
  <li>Utiliser des <b>variables d'instances</b> pour paramétrer des éléments uniques à ton instance (leur âge par exemple)</li>
</ul>


<h4>3.2.1. Méthodes d'instance</h4>
<h5>a) Les définir</h5>
<p>Imaginons que tu as envie que ton utilisateur dise bonjour (on t'avait dit que chez THP, on trouve ça important ?). Avec l'exemple ci-dessus, c'est possible : il suffit juste de faire <code>ton_utilisateur.greet</code>. Eh bien les méthodes d'instance peuvent faire beaucoup d'autres choses. Voici un autre exemple :</p>

<pre><code class="language-ruby">require "pry"
class User
  def greet
    puts "Bonjour, monde !"
  end
  def say_hello_to_someone(first_name)
    puts "Bonjour, #{first_name} !"
  end
end

binding.pry
puts "end of file"</code></pre>

<p>Rentre le code ci-dessus dans ta classe, exécute-le puis quand PRY se lance, tape : </p>

<pre><code class="language-ruby">julie = User.new
jean = User.new

julie.say_hello_to_someone("Patrick") # va produire un "Bonjour, Patrick !"
jean.say_hello_to_someone("Marie") # va produire un "Bonjour, Marie !"</code></pre>

<p>Tu as créé 2 instances de la classe <code>User</code> et sur chacun, tu as utilisé une méthode d'instance.</p>

<h5>b) Self</h5>
<p>Imaginons que tu aies envie d'utiliser l'instance, sur laquelle une méthode est appelée, dans le code de cette même méthode (#inception_instance :). C'est possible de le faire avec <code>self</code>.</p>

<p>Un exemple illustre cela ci-dessous avec la méthode <code>show_itself</code> qui va <code>puts</code> dans le terminal l'instance sur laquelle elle est appliquée : </p>


<pre><code class="language-ruby">require "pry"
class User
  def show_itself
    print "Voici l'instance : "
    puts self
  end

end

binding.pry
puts "end of file"</code></pre>

<p>À nouveau, rentre le code ci-dessus dans ta classe, exécute-le, puis quand PRY se lance, tape :</p>

<pre><code class="language-ruby">julie = User.new
jean = User.new

julie.show_itself #=> va produire un résultat du genre "Voici l'instance : #&lt;User:0x000055701febc118>"
jean.show_itself #=> va produire un résultat du genre "Voici l'instance : #&lt;User:0x000055701ff1c978>"</code></pre>

<p>Tu noteras au passage la forme sous laquelle le terminal te renvoie un objet quand tu le <code>puts</code>. Si l'instance que tu puts est de la classe <code>NomDeLaClasse</code>, le terminal t'affichera quelque chose du genre : <code>#&lt;NomDeLaClasse:0xyyyyyyy></code> où "0xyyyyyyy" est une sorte d'identifiant unique de l'instance. Les identifiants sont différents pour <code>julie</code> et <code>jean</code> mais si tu demandes plusieurs fois celui de <code>julie</code>, il ne change pas.</p>

<h4>3.2.2. Variables d'instance</h4>
<h5>a) Définir une variable d'instance</h5>
<p>Au sein d'une classe, on a défini des méthodes pour faire faire des actions à nos instances, mais on peut aussi <b>définir des variables qui définiront ces instances</b>. Par exemple quand tu crées un nouveau <code>User</code>, tu aimerais qu'il embarque avec lui des informations du genre : son prénom, son nom, son e-mail ou sa date de naissance. C'est ce qu'on va appeler des <b>variables d'instance</b>. Ces variables sont facilement identifiables dans le code, car elles ont un <code>@</code> devant leur nom. <br> Une variable d'instance doit être définie dans le code de la classe et sera accessible partout dans le code de la classe simplement en l'invoquant en mode <code>@variable = …</code>. Trêve de blabla, rien de mieux qu'un exemple pour illustrer tout ça.</p>

<p>Imaginons que tu aies envie de rattacher un e-mail à ton utilisateur. Cet e-mail sera propre à chaque utilisateur, et tu as envie de pouvoir le récupérer (=le lire) à tout moment ou même de le modifier. On va donc en faire une variable d'instance, un attribut unique à chaque instance de la classe que tu vas pouvoir appeler et modifier à ta guise. </p>
<p>Nous allons donc compléter le code comme suit :</p>
<ul>
  <li>Nous allons créer une méthode <code>update_email</code> qui va nous permettre de mettre à jour l’e-mail d'un <code>User</code>.</li>
  <li>Cette méthode va créer une variable d'instance qu'on nommera (très intelligemment) <code>@email</code>.</li>
  <li>Nous allons créer une deuxième méthode <code>read_email</code> pour pouvoir lire <code>@email</code> en dehors du code de la classe.</li>
</ul>
<p>Voici ta classe utilisateur :</p>

<pre><code class="language-ruby">require "pry"
class User

  def update_email(email_to_update)
    @email = email_to_update
  end

  def read_email
    return @email
  end

end

binding.pry
puts "end of file"</code></pre>

<p>À nouveau, rentre le code ci-dessus dans ta classe, exécute-le puis quand PRY se lance, tape :</p>

<pre><code class="language-ruby">julie = User.new
jean = User.new

julie.read_email #cette ligne doit te retourner "nil" car par défaut, @email n'existe pas
jean.read_email  #idem

julie.update_email("julie@julie.com") #on change la valeur du @email de julie
jean.update_email("jean@jean.com") #idem pour julien

puts julie.read_email # tu devrais récupérer cette fois l'email: "julie@julie.com"
puts jean.read_email # idem avec "jean@jean.com"</code></pre>

<p>Les méthodes <code>.update_email</code> et <code>.read_email</code> sont cools, mais, si on réfléchit bien, ce qui serait top serait de juste taper <code>julie.email</code> pour lire <code>@email</code> et de taper <code>julie.email = "machin"</code> pour le modifier à "machin". Ça serait à la fois plus simple à écrire et plus lisible pour un humain, non ? <br>
Eh bien Ruby a prévu ça grâce à 3 "fonctionnalités" que tu peux rajouter à la classe <code>User</code> :  <code>attr_reader</code>, <code>attr_writer</code>, et <code>attr_accessor</code>.</p>
<p> Nous allons les voir une à une</p>

<h5>b) Accès à une variable d'instance en écriture seulement (attr_writer)</h5>
<p>Cas d'usage de <code>attr_writer</code> : tu veux pouvoir enregistrer une variable d'instance facilement mais sans pouvoir la lire (exemple : un numéro de carte bleue). Il faudra indiquer dans ta classe que cette variable est un <b>attr_writer</b>. <br>
Voici comment faire : </p>


<pre><code class="language-ruby">require "pry"
class User
  attr_writer :mastercard #à mettre en en-tête de ta classe

  def read_mastercard
    return @mastercard
  end
end

binding.pry
puts "end of file"</code></pre>

<p>Voici les lignes à tester une à une dans la console PRY :</p>

<pre><code class="language-ruby">julie = User.new

julie.mastercard = "4242 4242 4242 4242" # la variable est bien sauvegardée dans l'objet
julie.mastercard # par contre on ne peut pas la lire facilement
julie.read_mastercard # on a créé une méthode spécifique pour la lire. Ici ça retourne : => "4242 4242 4242 4242"</code></pre>

<p>En gros, un <code>attr_writer</code> permet de modifier une variable d'instance sans avoir à coder une méthode <code>.update_variable(nouvelle_variable)</code>. Par contre, ta variable d'instance ne pourra pas être appelée sur l'instance avec <code>.variable</code>. Mais elle pourra être appelée dans le code à l'intérieur de ta classe (avec son nom en <code>@variable</code> : voir ci-dessus dans la méthode <code>read_mastercard</code>).</p>



<h5>c) Accès à une variable d'instance en lecture seulement (attr_reader)</h5>
<p>Cas d'usage de <code>attr_reader</code> : tu veux pouvoir lire une variable d'instance facilement mais sans pouvoir la modifier (exemple : une date de naissance qui ne risque pas de changer). Il faudra indiquer dans ta classe que cette variable est un <b>attr_reader</b>. <br>
Voici comment faire : </p>

<pre><code class="language-ruby">require "pry"
class User
  attr_reader :birthdate

  def update_birthdate(birthdate_to_update)
    @birthdate = birthdate_to_update
  end
end

binding.pry
puts "end of file"</code></pre>
<p>Les lignes de tests pour la console PRY :</p>

<pre><code class="language-ruby">julie = User.new
julie.update_birthdate("06/01/1991") #Cette méthode permet de rattacher la date de naissance à l'instance => Date de naissance sauvegardée !

julie.birthdate # on arrive bien à la lire. Ça retourne : => "06/01/1991"
julie.birthdate = "06/01/1991" #là on a une erreur. Impossible de la modifier ainsi</code></pre>
<p>En gros, un attr_reader permet de lire une variable d'instance sans avoir à coder une méthode <code>.read_variable</code>. Par contre, ta variable d'instance ne pourra pas être modifiée avec <code>instance.variable = nouvelle_valeur </code>. Mais elle pourra être appelée dans le code à l'intérieur de ta classe (avec son nom en <code>@variable</code> : voir ci-dessus dans la méthode <code>read_mastercard</code>).</p>


<h5>d) Accès à une variable d'instance en lecture ET en écriture (attr_accessor)</h5>
<p>Bon, on ne va pas se leurrer, les <code>attr_reader</code> et <code>attr_writer</code> doivent être vus, mais la majorité du temps, tu as envie d'accéder en lecture ET en écriture à tes variables d'instance. Le <code>attr_accessor</code> combine le <code>attr_reader</code> et <code>attr_writer</code>. <br>
Voici son usage : </p>

<pre><code class="language-ruby">require "pry"
class User
  attr_accessor :email
end

binding.pry
puts "end of file"</code></pre>

<p>Et pour le tester, utilise dans PRY : </p>

<pre><code class="language-ruby">julie = User.new
julie.email = "julie@julie.com"
puts julie.email #=> "julie@julie.com"</code></pre>

<p>Et voilà ! En une ligne, avec <code>attr_accessor</code> tu as créé une variable d'instance qui peut facilement être appelée (<code>instance.variable</code>) et modifiée (<code>instance.variable = nouvelle_valeur</code>) en dehors de la classe de l'instance !</p>


<h4>3.3. Travailler sur une classe</h4>
<p>Tu as vu comment travailler sur des instances précises de ta classe mais dans certains cas, tu as besoin de travailler sur ta classe de manière globale. Par exemple, tu as envie de compter le nombre d'instances qui ont été créées dans ta classe User. Faire <code>julie.count</code> n'aurait pas de sens : la méthode s'appliquant l'instance <code>julie</code>, on s'attend à ce qu'elle nous donne un résultat spécifique à <code>julie</code> et pas quelque chose qui concerne tout la classe <code>User</code>. Nous allons donc voir comment faire une méthode <code>.count</code> qu'on puisse appliquer à la classe même grâce à <code>User.count</code>. <br>
Ainsi tu vas voir :</p>

<ul>
  <li>La méthode <code>initialize</code>, une méthode indispensable qui permet d'exécuter du code à la création de ton instance (exemple : envoyer un email de bienvenue quand on fait <code>User.new</code>).</li>
  <li>Les variables de classe, qui concernent ta classe tout entière (par exemple : le compteur d'instances déjà créées);</li>
  <li>Les méthodes de classe, qui concernent ta classe tout entière (par exemple : une méthode <code>User.count</code> qui affiche le fameux compteur).</li>
</ul>

<h4>3.3.1. initialize</h4>
<p>La majorité du temps, créer une instance vide, c'est pas super intéressant : tu vas avoir envie que dès le départ, elle fasse quelque chose ou a minima qu'elle soit définie par des variables d'instance précises. À quoi bon créer un nouvel utilisateur si tu ne lui définis pas de suite un e-mail, un nom, un prénom ?<br>
Sache qu'il est possible d'exécuter du code en même temps que la création d'une instance. Sache que c'est la méthode <code>initialize</code> qui fait ça. Appliquons l'exemple que je viens de citer :</p>

<pre><code class="language-ruby">require "pry"
class User
  attr_accessor :email

  def initialize(email_to_save)
    @email = email_to_save
    puts "Email : Bienvenue !!"
  end
end

binding.pry
puts "end of file"</code></pre>

<p>Si tu testes ce code dans PRY :</p>

<pre><code class="language-ruby">julie = User.new("julie@julie.com") #dès le départ, tu rattaches un email à l'instance et affiche un message
#=> "Email : Bienvenue !!"
puts julie.email #on vérifie que l'email est bien enregistré. ok, ça retourne => "julie@julie.com"
jean = User.new #tu vas avoir une erreur car tu as oublié l'email => ArgumentError (wrong number of arguments (given 0, expected 1))</code></pre>

<p>La méthode initialize est très courante. Retiens-donc la bien 😉</p>

<h4>3.3.2. Variables de classe</h4>
<p>Il peut être très utile de pouvoir déclarer et utiliser des variables qui concernent toute une classe. Par exemple une variable qui stocke tous tes utilisateurs créés, ou alors une variable qui les compte. <br>Grâce aux <b>variables de classe</b> tu peux faire ceci très facilement. Une variable de classe commence par <code>@@</code> et est définie en en-tête de ta classe (juste après les <code>attr_</code>). Exemple : </p>

<pre><code class="language-ruby">require "pry"
class User
  attr_accessor :email
  @@user_count = 0 # on initialise la variable de classe qui sera un compteur du nombre d'instance

  def initialize(email_to_save)
    @email = email_to_save
    @@user_count = @@user_count + 1 # un utilisateur vient d'être créé : on ajoute donc 1 au compteur
  end
end</code></pre>

<p>Comment appeler cette variable ? Nous allons voir les méthodes de classe qui sont prévues pour ceci justement.</p>

<h4>3.3.3. Les méthodes de classe</h4>
<p>Une méthode de classe est appelée avec <code>NomDeLaClasse.methode</code> (exemple: <code>User.new</code>). Elles sont définies de la même façon que les méthodes d'instance, sauf que tu ajoutes <code>self.</code> avant ton nom de méthode. Assez de blabla, voici une méthode qui affiche une variable de classe :</p>


<pre><code class="language-ruby">require "pry"
class User
  attr_accessor :email
  @@user_count = 0 # on initialise la variable de classe

  def initialize(email_to_save)
    @email = email_to_save
    @@user_count = @@user_count + 1
  end

  def self.count
    return @@user_count
  end
end

binding.pry
puts "end of file"</code></pre>

<p>Quelques lignes pour tester le code dans PRY :</p>


<pre><code class="language-ruby">p User.count #=> 0
julie = User.new("julie@julie.com")
p User.count #=> 1
jean = User.new("jean@jean.com")
p User.count => 2</code></pre>

<h3>3.4. Méthodes publiques, méthodes privées</h3>
<p>Bon allez, dernier élément du cours et après on passe à la suite. Imaginons que tu as envie de vérifier si l’e-mail de l'utilisateur est écrit au bon format (quelque chose comme "truc@machin.com" et non pas "truc.com"). Il faudrait faire une vérification à l'initialize, qui enverrait chier l'utilisateur si l’e-mail est mauvais.</p>

<p>Notre code ressemblerait à quelque chose du style :</p>

<pre><code class="language-ruby">require "pry"
class User
  attr_accessor :email #on définit une variable d'instance lisible et modifiable

  def initialize(email_to_save) #on définit un initialize
    if check_email(email_to_save) # on vérifie l’e-mail proposé
      @email = email_to_save #l’e-mail est ok => on le sauve dans l'instance
    else
      puts "ERREUR ! EMAIL FOIREUX. Recommence" #l’e-mail est non ok => message d'erreur
    end
  end

  def check_email(email_to_save)
    # du code pour vérifier l’e-mail (on ne rentre pas dans le détail)
    # si l’e-mail est ok, ça renvoie TRUE. Sinon FALSE
  end

end</code></pre>

<p>La logique est très bonne, sauf que avec ce code nous pourrions avoir accès à une méthode <code>julie.check_email(exemple_d_email)</code> qui nous renverrait TRUE ou FALSE. Ce <code>julie.check_email(exemple_d_email)</code> n'a pas trop de sens, car on peut entrer n'importe quel <code>exemple_d_email</code> sans rapport avec l'objet <code>julie</code>. <br>
Pour ne pas pouvoir faire ce genre d'appel à <code>check_email</code> qui serait un hors-sujet voire (dans certains cas) dangereux, on va mettre <code>check_email</code> dans les méthodes privées car <b>par défaut, une méthode est "publique"</b>. <br>
<b>Les méthodes privées peuvent être exécutées depuis le code de la classe mais pas à l'extérieur (donc pas de <code>julie.check_email</code> possible)</b></p>
<p>Voici un exemple : </p>

<pre><code class="language-ruby">require "pry"
class User
  def truc_public
    # on peut faire julie.truc_public
  end

  private #Toutes les méthodes en dessous de cette balise seront privées. A mettre en bas donc !

  def truc_private
    # impossible de faire julie.truc_private
  end

end</code></pre>

<p>Les méthodes privées reviendront dans Rails, c'est pour cela que nous les abordons ici.</p>

<h3>3.5. Ruby, POO, importance des classes</h3>

<h4>3.5.1. L'importance de l'orienté objet</h4>
<p>J'imagine bien ta réaction : pourquoi se faire chier à faire de l'objet quand les programmes que l'on a fait la semaine dernière marchent bien sans ? La raison est simple : l'orienté objet permet de décomposer son programme en plein de fichiers plus courts et surtout <b>dont la fonction est bien définie</b>. Du coup l'ensemble de ton programme devient plus facile à comprendre quand tu as une classe <code>User</code>, une classe <code>Tweet</code>, une classe <code>like</code>, une classe <code>UserViews</code>, etc. Rien qu'en lisant leur nom tu as une idée de leur fonction :) <br> Pour un script simple, le faire en objet ou pas ne change rien, mais pour les applications plus complexes avec plusieurs fichiers, c'est indispensable de bien penser l'architecture. Une bonne architecture veut dire un programme plus lisible, plus facile à comprendre, pour toi comme pour les autres. Et un programme lisible et compréhensible est un programme plus facile à modifier.</p>

<p>Si maintenant tu te dis que c'est plus l'embrouille qu'autre chose, nous aurons toute cette semaine pour penser objet afin que toutes ces variables d'instance et autres <i>self</i> viennent naturellement.</p>

<p>Voici 3 astuces pour expliquer la philosophie de l'objet :</p>

<ul>
  <li>le Principe de Responsabilité Unique : <b>une classe ne doit répondre qu'à une fonction et une fonction unique</b>. Par exemple pour notre scrappeur fou de la semaine dernière, s'il constituait un seul et même programme, il aurait eu trois classes (et un fichier par classe) :
    <ul>
      <li><code>CryptoScrapper</code></li>
      <li><code>TownHallScrapper</code></li>
      <li><code>RepresentativeScrapper</code></li>
      <li>Voir même une classe <code>Menu</code> qui permet de lancer un petit menu dans le terminal et appelle, en fonction de ce que l'utilisateur choisit de faire, une des 3 classes fonctionnelles ci-dessus pour scrapper quelque chose.</li>
    </ul></li>
  <li>Les méthodes ne doivent pas faire plus de 10 lignes. L'objectif est d'avoir des méthodes simples, courtes, facilement compréhensibles. Si tu dépasses, découpe-la en deux.</li>
  <li>Pas plus de 4 paramètres en entrée d'une méthode. Si tu dépasses, découpe-la en deux.</li>
</ul>

<p>Si tu suis ces règles, tu devrais être un champion de la POO et n'avoir aucun soucis pour briller pendant un test technique.</p>

<h4>3.5.2. Dans Ruby, "tout est objet"</h4>
<p>Pourquoi la POO est-elle si importante dans Ruby ? C'est principalement parce que Ruby est un langage intégralement orienté objet. Je m'explique. <br>
  Dans les autres langages de programmation, un <code>string</code> ou un <code>float</code> est un type de variable et rien de plus. En Ruby, ce sont en fait des objets car tout, dans ce langage, est objet. Et donc dans le code source de Ruby, tu pourrais trouver une classe <code>String</code> comme ceci :</p>

<pre><code class="language-ruby">class String
  def each
    # code pour faire une boucle each sur une instance de "String"
  end

  def length
    # code pour obtenir la longueur d'une instance de "String"
  end

end</code></pre>

<p>Je t'ai donc menti en début de cours en te disant "bravo, tu viens de créer ton premier objet" : tu en manipules depuis le début sans le savoir ! Et quand tu as fait des <code>array.each</code> ou <code>"bonjour".length</code>, tu as fait appel à des méthodes d'instance des classes <code>Array</code> ou <code>String</code>. <br>
C'est là tout l'élégance de Ruby. C'est un langage de programmation où absolument TOUT sera imbriqué dans des classes. Au début cela fait un peu bizarre, mais sache que cette logique est une grande force de Ruby.</p>

<h4>3.5.3. Tout imbriquer dans des classes</h4>
<p>Tu t'en souviens quand nous te disions de découper tous tes programmes en méthodes, puis de les appeler avec une méthode "orchestre" <code>.perform</code>. Eh bien à partir de maintenant nous te demanderons de faire exactement la même chose avec les classes : <b>chaque fichier de Ruby doit correspondre à une classe et une classe doit être un fichier !</b> <br>En Ruby, un dossier contenant un programme complet se trouve intégralement imbriqué dans des classes. Et tu exécutes le tout avec une ligne <code>App.new</code> appelant une classe <code>App</code> située dans un fichier <code>app.rb</code>.</p>

<p>Ne t'en fais pas si tu trouves ceci abstrait : nous avons toute cette semaine pour te mettre dans le bain de la POO, pour que tu puisses penser objet d'ici vendredi. Sache juste que, par exemple, pour le programme du scrapper, tu aurais mis tous tes scrappeurs dans une classe nommée <code>Scrapper</code>, et tu aurais appelé ton scrappeur en faisant <code>Scrapper.new</code> dans un fichier <code>app.rb</code> qui ne contiendrait presque que ceci.</p>


<h2>4. Points importants à retenir</h2>
<p>La ressource est très complète et hyper dense. Rassure-toi, ces informations constituent presque tout ce qu'il faut voir pour aborder une semaine entière de POO. Nous te conseillons de la sauvegarder dans un coin et d'y revenir au fur et à mesure des projets.</p>

<p>Voici un récapitulatif de tout ce qu'il faut savoir pour bien aborder une semaine d'orienté objet. Nous commençons par un programme qui contient tout ce que tu as vu d'important dans cette ressource :</p>


<pre><code class="language-ruby">class User
  attr_accessor :email, :encrypted_password
  @@user_count = 0

  def initialize(email_to_save)
    @email = email_to_save
    @@user_count = @@user_count + 1
  end

  def change_password(new_password)
    @encrypted_password = encrypt(new_password)
  end

  def show_itself
    puts self
  end

  def self.count
    return @@user_count
  end

  private

  def encrypt(string_to_encrypt)
    return "##ENCRYPTED##"
  end

end</code></pre>

<p>Puis un récap du cours :</p>

<p>Une classe se déclare avec <code>class TaClasse</code>. <br>Une instance correspond à un objet précis de ta classe (l'utilisatrice Julie pour ta classe User).</p>

<p>Les méthodes d'instances permettent d'exécuter des méthodes sur des instances de classe (la méthode <code>change_password</code> ci-dessus est une méthode d'instance). <br>
Dans le code d'une méthode, il est possible d'appeler l'instance concernée par une méthode d'instance avec <code>self</code>. <br>
Les variables d'instance ont un <code>@</code> et concernent une instance précise de ta classe (<code>@email</code> est une variable d'instance). <br>
Il est possible d'appeler et de modifier des variables d'instance grâce à <code>attr_accessor</code>.</p>

<p>Les méthodes de classe concernent la classe de manière globale (<code>self.count</code> est une méthode de classe car, pour compter les instances de la classe User, nous voulons faire <code>User.count</code> et non pas <code>julie.count</code> qui n'aurait pas de sens). <br>
Il est possible de modifier la méthode <code>new</code> et d'y ajouter du code grâce à <code>initialize</code>.<br>
Il existe aussi des variables de classe qui concernent la classe de manière globale et qui s'écrivent avec <code>@@</code>. <br>
On les définit après les <code>attr_</code> (<code>@@user_count</code> est une variable de classe dans l'exemple ci-haut).</p>

<p>Enfin, définir des méthodes comme "privées" permet d'organiser ton code tout en évitant de pouvoir les appeler sur une instance, par exemple <code>julie.ta_méthode_privée</code> (<code>.encrypt</code> est une méthode privée, car je n'ai pas envie de faire <code>julie.encrypt</code>).</p>


<h2>5. Pour aller plus loin</h2>
<p>Pour les grands champions qui veulent aller plus loin :</p>

<ul>
  <li>LaunchSchool sont les champions des leçons exhaustives, <a href="https://launchschool.com/books/oo_ruby/read/introduction" target="_blank">voici celle sur la POO</a></li>
  <li>Si tu demandes à n'importe quel développeur Ruby "comment aller plus loin en POO" (voire en Ruby, tellement c'est considéré comme la bible), ne cherche pas plus que THE référence : <a href="https://www.poodr.com/" target="_blank">Practical Object-Oriented Design, An Agile Primer Using Ruby (POODR)</a>, un livre écrit par Sandi Metz.</li>
</ul>

          </div>
        </div>
        </div>
      </div>
    </div>
  </div>
</div>

  <div class="container">
  <div class="row">
    <div class="col-12">
      <div class="card">
        <div class="card-header" style="border-top: 3px solid #5E66E5 " >
          <h1>Cours : Faire des tests avec de l&#39;orienté objet</h1>
          <a class="heading-elements-toggle">
          <i class="la la-ellipsis-v font-medium-3"></i>
          </a>
          <div class="heading-elements">
            <ul class="list-inline mb-0">
              <li><a data-action="collapse"><i class="ft-minus"></i></a></li>
              <li><a data-action="expand"><i class="ft-maximize"></i></a></li>
            </ul>
          </div> 
      </div>
      <div class="card-content collapse show">
        <div class="card-body">
          <div class="tab-pane active" id="home1" role="tabpanel">
          

<h2>1. Introduction</h2>
<p>Tu as vu comment faire des tests avec Rspec et des petits programmes Ruby. Maintenant nous allons voir comment faire des tests avec des classes. Ne t'en fais pas, ce n'est pas bien compliqué.</p>

<h2>2. Historique</h2>
<p>Ruby est un langage de programmation orienté objet (POO). La communauté Ruby insiste beaucoup sur les tests. Le combo des deux est inévitable 👌</p>

<h2>3. La ressource</h2>
<p>L'arborescence de ton projet ne changera pas trop par rapport à ce que tu vois d'habitude :</p>

<pre><code class="language-bash">mon_projet
├── lib
│   └── user.rb
├── spec
│   ├── spec_helper.rb
│   └── user_spec.rb
├── README.md
├── Gemfile
├── Gemfile.lock
├── Autres fichiers (.env, .gitignore)
└── .rspec</code></pre>

<p>Ainsi, un fichier <code>user_spec.rb</code> irait tester la classe User. Voici un exemple d'un fichier de tests :</p>

<pre><code class="language-ruby">
require_relative '../lib/user'

describe User do

  before(:each) do
    # ligne trouvée ici : https://geminstallthat.wordpress.com/2008/08/11/reloading-classes-in-rspec/
    # qui permet de remettre à zéro la classe. Pratique pour la méthode count, mais pas obligatoire.
    Object.send(:remove_const, 'User')
    load 'user.rb'
  end

  describe 'initializer' do

    it 'creates an user' do
      user = User.new("email@email.com")
      expect(user.class).to eq(User)
    end

    it 'saves @email as instance variable' do
      email = "email@email.com"
      user = User.new(email)
      expect(user.email).to eq(email)
    end

    it 'adds one to the @@count global variable' do
      count = User.count
      user = User.new("email@email.com")
      expect(User.count).to eq(count + 1)
    end
  end



  describe 'instance methods' do

    describe 'change_password' do
      it "changes password to ##ENCRYPTED##" do
        user = User.new("email@email.com")
        password = "some string"
        user.change_password(password)
        expect(user.encrypted_password).to eq("##ENCRYPTED##")
      end
    end

    describe 'show_itself' do
      it "shows itself" do
        user = User.new("email@email.com")
        user.show_itself
        expect do
          user.show_itself
        end.to output("#{user}\n").to_stdout
        # OK celle là est super hard, mais en même temps c'est pas des méthodes que l'on utilise souvent. Solution trouvée ici : https://stackoverflow.com/a/38377720
      end
    end

  end

  describe 'instance variables' do

    describe '@email' do

      it 'can be read' do 
        email = "email@email.com"
        user = User.new(email)
        expect(user.email).to eq(email)
      end

      it 'can be written' do 
        email = "email@email.com"
        user = User.new(email)
        email_2 = "email_2@email.com"
        user.email = email_2
        expect(user.email).not_to eq(email)
        expect(user.email).to eq(email_2)
      end

    end

  end

  describe 'class methods' do

    describe 'self.count' do
      it 'shows the number of users' do 
        user_1 = User.new("email1@email.com")
        user_2 = User.new("email2@email.com")
        user_3 = User.new("email3@email.com")
        expect(User.count).to eq(3)
      end
    end

  end

end</code></pre>

<p>Ce fichier est assez exhaustif et va plutôt loin dans les tests. Le but (surtout pour toi qui débutes) ne sera pas de TOUT tester lors des projets, mais de tester a minima les méthodes importantes. L'objectif de la semaine reste de bien comprendre la POO.</p>


<h2>4. Points importants à retenir</h2>
<p>Puisque 1 classe = 1 fichier, on aura aussi 1 classe = 1 fichier de tests. </p>
<p>Le reste n'est pas très différent des tests unitaires que tu as faits jusque-là. Reporte-toi à mon exemple ci-dessus pour visualiser quelques tests de base à mener sur une classe.</p>

<h2>5. Pour aller plus loin</h2>
<p>Voici <a href="http://tutorials.jumpstartlab.com/topics/internal_testing/rspec_practices.html" target="_blank">un super article</a> des JumpStarts Tutorials qui te donnera toutes les bonnes pratiques de Ruby pour tester des classes en mode BG.</p>
          </div>
        </div>
        </div>
      </div>
    </div>
  </div>
</div>


  <div class="container">
  <div class="row">
    <div class="col-12">
      <div class="card">
        <div class="card-header" style="border-top: 3px solid #FF4081 " >
          <h1>Projet : Gestionnaire de calendrier</h1>
          <a class="heading-elements-toggle">
          <i class="la la-ellipsis-v font-medium-3"></i>
          </a>
          <div class="heading-elements">
            <ul class="list-inline mb-0">
              <li><a data-action="collapse"><i class="ft-minus"></i></a></li>
              <li><a data-action="expand"><i class="ft-maximize"></i></a></li>
            </ul>
          </div> 
      </div>
      <div class="card-content collapse show">
        <div class="card-body">
          <div class="tab-pane active" id="home1" role="tabpanel">
          
<h2>1. Introduction</h2>
<p>Assez de blabla, place à la pratique ! Nous savons que les informations que tu viens d'assimiler sont énormes. Donc ne te fais pas de soucis, nous n'allons pas t'embrouiller avec encore plus de choses compliquées. Déjà, nous n'allons pas te prendre la tête avec les tests puisque nous allons te demander de tester le minimum syndical. L'objectif est de se mettre dans le bain de la POO.</p>

<p>Aujourd'hui tu vas révolutionner le monde de la tech puisque tu vas créer un nouveau calendrier pour prendre des rendez-vous super efficacement. Pierre Valade n'a qu'à bien se tenir !</p>

<p>Tu vas créer une application où tu pourras créer des événements avec une date de début, une durée, et un nom. Tu pourras leur donner un lieu, des utilisateurs, et on affichera la liste totale des rendez-vous. L'avantage de penser objet pour l'application est que sa décomposition sera extrêmement simple.</p>



<h2>2. Le projet</h2>
<h3>2.1. Résumé et structure</h3>
<h4>2.1.1. Résumé</h4>
<p>Le programme sera simple : nous allons faire une classe Event qui aura plusieurs attributs : une date de début, une durée, un titre, ainsi que des participants. À partir de la date de début et de la durée, nous allons calculer des méthodes pour savoir si l'événement est passé ou pas, ou bien s'il est prévu pour bientôt. Puis nous coderons une façon d'afficher l'événement de manière stylée.</p>

<p>Avant de faire plein d'événements, nous allons coder une petite classe utilisateur pour se mettre dans le bain.</p>

<p>Ce projet va te faire manipuler les classes et les temps.</p>


<h4>2.1.2. Structure</h4>
<p>Puisque nous sommes super sympas et que ce n'est jamais facile de faire face au syndrome de la page blanche, <a href="https://github.com/felhix/ruby-event-oop" target="_blank">voici un repository vide</a> qui contiendra notre application. La structure est très similaire à ce que l'on voit d'habitude, à une différence :</p>

<pre><code class="language-shell">mon_projet
├── lib
│   ├── event.rb
│   └── user.rb
├── spec
│   ├── spec_helper.rb
│   ├── event_spec.rb
│   └── user_spec.rb
├── app.rb
├── README.md
├── Gemfile
├── Gemfile.lock
├── Autres fichiers (.env, .gitignore)
└── .rspec</code></pre>

<p>Le fichier <code>app.rb</code> va appeler les fichiers <code>lib/event.rb</code> et <code>lib/user.rb</code>. Bref c'est l'équivalent de la méthode perform 👌</p>


<h3>2.2. Petit tour de chauffe, une classe User</h3>
<h4>2.2.1. class User</h4>
<p>Avant de commencer par des événements qui déchirent, on va te demander de créer une classe pour les utilisateurs de ton super agenda. C'est une classe très simple qui servira de tour de chauffe pour ton application.</p>

<p>Voici ce que nous voulons avec notre utilisateur : il faut pouvoir créer un utilisateur. Un utilisateur a un e-mail et un nom. Il faut aussi pouvoir récupérer facilement la liste des utilisateurs.</p>



<p>Nous avons les spécificités, maintenant on va les traduire en langage technique POO. Voici ce que cela veut dire :</p>
<ul>
  <li>Un utilisateur a un <code>email</code> et un <code>name</code> que l'on peut lire et modifier à sa guise (indice : <code>attr_accessor</code>)</li>
  <li>À la création, il faudra passer l'email en paramètre pour l'utilisateur (il faudra faire : <code>User.new("email@email.com")</code>)</li>
  <li>Il est possible de faire <code>User.all</code> pour récupérer un array contenant tous les utilisateurs enregistrés (indice : il faudra une variable de classe qui est un array qui contient tous les utilisateurs)
  <ul>
    <li>Celle-là n'est pas hyper simple quand on débute, c'est normal si tu prends une demi-heure dessus 😘 Inspire-toi de la ressource sur la POO plus haut.</li>
  </ul></li>
</ul>

<div class="card box-shadow-0 border-info">
  <div class="card-content collapse show">
    <div class="card-body">
      <h4 class="card-title">🚀 ALERTE BONNE ASTUCE</h4>
      <p class="card-text">Comme tout est bien branché, tu peux tester sans soucis tes <code>User.new</code> dans le fichier <code>app.rb</code>. N'hésite pas à utiliser binding.pry qui est très pratique aussi.</p>
    </div>
  </div>
</div>

<h4>2.2.2. Un petit test ?</h4>
<p>Va dans le fichier <code>spec/user_spec.rb</code> et fais donc un test qui vérifie que l'utilisateur est bien créé. Bon on est sympa, on l'a fait pour toi. De rien 😉</p>

<h3>2.3. Les événements</h3>
<p>Nous allons nous occuper de notre classe Event. Voici ce que nous voulons faire avec notre nos objets événements : </p>

<ul>
  <li>Un événement a une date de début, une durée, un titre, un ou plusieurs utilisateurs</li>
  <li>Il faut être capable de décaler un événement au lendemain, même heure</li>
  <li>Il faut qu'il soit possible de récupérer des informations comme :
  <ul>
    <li>La date de fin</li>
    <li>Savoir si un événement est passé ou non</li>
    <li>Savoir si un événement est dans moins de 30 minutes (au cas où nous voudrions envoyer un rappel)</li>
  </ul></li>
  <li>Il faut que l'on soit capables d'afficher de manière présentable un événement</li>
</ul>

<p>OK, sauf si tu es un champion, j'imagine que tout ceci ne t'inspire pas trop. Eh bien nous allons faire un petit pas à pas pour que tout aille bien ✌</p>

<h4>2.3.1. Attributs de l'événement</h4>
<p>Voici les attributs de notre événement :</p>

<ul>
  <li>Un événement a une <code>start_date</code> qui est de type <code>Time</code> (on y reviendra)</li>
  <li>Un événement a une <code>length</code>, qui est un <code>integer</code> qui représente le nombre de minutes</li>
  <li>Un événement a un <code>title</code>, qui est un <code>string</code></li>
  <li>Un événement a un ou plusieurs <code>attendees</code>, qui est un array qui contient une liste d’e-mails</li>
</ul>

<p>En gros, il faut que l'on soit capable de créer un événement qui invite truc@machin.com et bidule@chose.fr en faisant :</p>

<pre><code class="language-ruby">Event.new("2019-01-13 09:00", 10, "standup quotidien", ["truc@machin.com", "bidule@chose.fr"])</code></pre>

<h5>2.3.1.1. Date</h5>
<p>Ce projet te fera jouer avec les Times, une fonctionnalité très cool de Ruby.</p>

<div class="card box-shadow-0 border-info">
  <div class="card-content collapse show">
    <div class="card-body">
      <h4 class="card-title">🚀 ALERTE BONNE ASTUCE</h4>
      <p class="card-text">On va tester les objets de type <code>Time</code>. Lance IRB, puis fais : <code>t = Time.now</code>. Il devrait te renvoyer un truc du genre : <code>2019-01-23 12:03:14 +0100</code>. Voici un Time. Il existe plein de méthodes pour changer ou s'amuser avec l'heure d'un Time que tu peux retrouver <a href="https://ruby-doc.org/stdlib-2.6/libdoc/time/rdoc/Time.html" target="_blank">dans la doc</a>.</p>
      <p>Une méthode qui nous intéresse est <a href="https://ruby-doc.org/stdlib-2.6/libdoc/time/rdoc/Time.html#method-c-parse" target="_blank">parse</a>, qui permet de convertir un string en Time. Essaie donc :</p>
      <pre><code class="language-ruby">require 'time' #=> true
Time.parse("2010-10-31 12:00") #=> 2010-10-31 12:00:00 +0100</code></pre>
      <p>Parfait, on a réussi à transformer un string en date. On pourra faire des événements faciles avec ceci.</p>
    </div>
  </div>
</div>

<p>Mets donc la <code>start_date</code> en <code>attr_accessor</code> et arrange-toi pour que <code>Event.new("2010-10-31 12:00")</code> arrive à enregistrer <code>start_date</code> en Time. Avec ceci on pourra savoir très facilement par exemple si l'événement est dans le futur ou non.</p>

<div class="card box-shadow-0 border-info">
  <div class="card-content collapse show">
    <div class="card-body">
      <h4 class="card-title">🤓 QUESTION RÉCURRENTE</h4>
      <p class="card-text"><b>Mais dis donc Jamy, ça change quelque chose si notre <code>attr_accessor</code> est un type de donnée spécial, genre Time, ou array ?</b><br>
      Absolument pas. Tu peux mettre tout type de données en <code>attr_accessor</code> : integer, array, hash, etc. Nous verrons, quand tu seras bien à l'aise, les enjeux de ceci.</p>
    </div>
  </div>
</div>


<h5>2.3.1.2. Durée</h5>
<p>Maintenant, deuxième attribut : la durée de notre événement. Pour que ce soit simple, nous allons représenter ceci en integer qui sera le nombre de minutes de l'événement. Ainsi, si tu veux créer un événement de 30 minutes au dimanche 6 janvier 2019 à 14 h, il faudra rentrer :</p>

<pre><code class="language-ruby">Event.new("2019-01-06 14:00", 30)</code></pre>

<h5>2.3.1.3. Title</h5>
<p>Un événement a un titre ("point récap", "brainstorm", "rencontre avec Solucom", etc). Il faut l'ajouter à sa création. Si l'on veut créer un événement le 16 janvier à 9 h de 10 minutes intitulé "standup quotidien", il faudra rentrer :</p>

<pre><code class="language-ruby">Event.new("2019-01-13 09:00", 10, "standup quotidien")</code></pre>

<h5>2.3.1.4. Attendees</h5>
<p>Presque fini : il faut pouvoir être capable d'enregistrer une liste d’e-mails dans notre événement comme ceci :</p>

<pre><code class="language-ruby">Event.new("2019-01-13 09:00", 10, "standup quotidien", ["truc@machin.com", "bidule@chose.fr"])</code></pre>

<h5>2.3.1.5. Des tests</h5>
<p>Fais donc un test pour vérifier que (comme pour les utilisateurs), il est possible de créer un événement.</p>

<h4>2.3.2. Décaler un événement</h4>
<p>Des fois dans ton agenda, il t'arrive de décaler un événement à 24 heures plus tard. Fais donc une méthode <code>postpone_24h</code> qui décale la <code>start_date</code> d'un évènement au lendemain, même heure.</p>


<div class="card box-shadow-0 border-info">
  <div class="card-content collapse show">
    <div class="card-body">
      <h4 class="card-title">🚀 ALERTE BONNE ASTUCE</h4>
      <p class="card-text">D'après <a href="https://stackoverflow.com/a/6936231" target="_blank">cette réponse</a>, tu peux facilement modifier une heure. Par exemple pour décaler un time de 24 h, tu fais :</p>
      <pre><code class="language-ruby">time = time + 60 * 60 * 24 # Ce calcul correspond au nombre de secondes dans 24 h : 60secs * 60mn * 24h</code></pre>
      <p>En effet, par défaut, <b>les durées sont exprimées en secondes en Ruby</b>. Penses-y, car la durée de tes events est, elle, en minutes !</p>
    </div>
  </div>
</div>


<h4>2.3.3. Temporalité</h4>
<p>Dans cette section, nous allons coder des méthodes qui vous te permettre de faire plusieurs choses avec la date de début et la durée :</p>

<ul>
  <li>Connaître la date de fin</li>
  <li>Savoir si un événement a déjà eu lieu (est-ce qu'il a commencé)</li>
  <li>Savoir si au contraire un événement est dans le futur</li>
  <li>Savoir si un événement est bientôt (dans moins de 30 minutes)</li>
</ul>

<h5>2.3.3.1. Date de fin</h5>
<p>Avec la <code>start_date</code> et la <code>length</code>, code une méthode intitulée <code>end_date</code> qui va calculer et te retourner l'heure de fin d'un événement. <br>Astuces : utilise-le <code>+</code> vu plus haut et rappelle-toi qu'une durée est en secondes (par défaut) en Ruby 😉</p>

<h5>2.3.3.2. A-t-il commencé ?</h5>
<p>Créé une méthode <code>is_past</code> pour savoir si un événement est passé ou pas. Pour savoir s'il est passé, il suffit juste de savoir si la <code>start_date</code> est dans le futur ou pas. Si l'événement est dans le passé, retourne <code>true</code>, sinon retourne <code>false</code>.</p>

<div class="card box-shadow-0 border-info">
  <div class="card-content collapse show">
    <div class="card-body">
      <h4 class="card-title">🚀 ALERTE BONNE ASTUCE</h4>
      <p class="card-text">Pour savoir si un time est avant un autre, rien de plus simple :</p>
      <pre><code class="language-ruby">time_1 < time_2</code></pre>
      <p>Le time de maintenant est <code>Time.now</code>. À partir de là, cela devrait aller 🤘</p>
    </div>
  </div>
</div>


<h5>2.3.3.3. Est-il dans le futur ?</h5>
<p>Code une méthode <code>is_future</code> qui est l'inverse de <code>is_past</code>.</p>

<div class="card box-shadow-0 border-info">
  <div class="card-content collapse show">
    <div class="card-body">
      <h4 class="card-title">🚀 ALERTE BONNE ASTUCE</h4>
      <p class="card-text">Tu peux l'avoir fait en reprenant la méthode ci-haut, et c'est une excellente technique. Voici une petite astuce si tu es à l'aise et que tu aimes bien le code propre. En Ruby on adore la lisibilité. Si une méthode est l'inverse d'une autre, voici ce que l'on fait généralement :</p>
      <pre><code class="language-ruby">def is_future
          !self.is_past
      end</code></pre>
      <p> <code>!</code> signifie "inverse de". <code>self.is_past</code> permet d'appeler la fonction <code>is_past</code> sur le même objet que celui ciblé par la fonction <code>is_future</code> </p>
    </div>
  </div>
</div>


<h5>2.3.3.4. Is it soon ?</h5>
<p>Dernière méthode, ce serait bien de savoir si un événement est bientôt. C’est-à-dire si sa <code>start_date</code> est dans moins de 30 minutes. Code donc une méthode <code>is_soon</code></p>




<h4>2.3.4. to_s</h4>
<p>Maintenant que tu as plein de méthodes pour connaître plein de choses sur tes événements, nous allons coder une méthode pour afficher joliment un événement. Pour le moment, si tu fais <code>p event</code>, il te sort un truc pas très ergonomique du genre <code>#&lt;Event:0x00005600b4a9a3c0 @email="kikou@truc.com", blabla></code>. Ce serait bien d'avoir une méthode qui affiche l'événement avec un truc du genre :</p>

<pre><code class="language-shell">event.to_s
Titre : RDV super important
Date de début : 2010-10-31 12:00
Durée : 30 minutes
Invités : pierre@pierre.com, jean@jean.jean</code></pre>

<div class="card box-shadow-0 border-success">
  <div class="card-content collapse show">
    <div class="card-body">
      <h4 class="card-title">📚 INSTANT CULTURE GÉ</h4>
      <p class="card-text">Une méthode qui affiche de manière jolie un objet s'appelle en général <code>to_s</code>, car elle convertit le blob bizarre vu plus haut en string bien affiché.</p>
    </div>
  </div>
</div>


<h4>2.3.5. guests sont des users</h4>
<p>Le gros point fort de la POO, c'est de mélanger les classes entre elles, afin d'avoir un code propre bien rangé. Pour l'attribut, au lieu d'avoir une array de string, ce serait bien d'avoir une array d'utilisateurs de la classe <code>User</code>.</p>

<p>Et bien figure-toi qu'il est possible, grâce aux branchements faits, d'écrire dans le fichier <code>app.rb</code>  :</p>

<pre><code class="language-ruby">julie = User.new("julie@julie.com")
jean = User.new("jean@jean.com")

e = Event.new("2019-01-13 09:00", 10, "standup quotidien", [julie, jean])
puts "Voici l'email du premier attendee de l'événement : #{e.attendees.first.email}</code></pre>"

<p>Plutôt cool, non ? Eh bien c'est tout l'intérêt de la POO. On code des classes, puis nous avons juste à les imbriquer entre elles pour avoir un code super lisible, bien ordonné, où l'on ne se perd pas.</p>

<p><b>Dernier exercice : </b> dans la classe des utilisateurs, code une méthode <code>self.find_by_email(email)</code> qui permet de retrouver une instance d'utilisateur à partir de son email. Ainsi, nous pourrions faire : </p>

<pre><code class="language-ruby">User.new("julie@julie.com")
User.new("jean@jean.com")

julie = User.find_by_email("julie@julie.com")
jean = User.find_by_email("jean@jean.com")

e = Event.new("2019-01-13 09:00", 10, "standup quotidien", [julie, jean])
puts "Voici l'email du premier attendee de l'événement : #{e.attendees.first.email}"</code></pre>

<h3>2.4. D'autres applications</h3>
<p>Le programme est fini (pfiou !). J'espère que tu n'as pas été trop perdu cette première journée de POO. Demain nous continuerons à faire des programmes comme celui-ci pour qu'à la fin de la semaine, tu penses tes programmes en mode objets et classes.</p>

<p>Voici par exemple d'autres classes que l'on aurait pu ajouter à ton programme pour le rendre plus cool. Si tu as déjà fini le projet, prends le temps de les coder (attention c'est chaud !) :</p>

<h4>2.4.1. EventCreator</h4>
<p>Nous pourrions faire une classe <code>EventCreator</code> qui, à sa création, demandera de manière graphique à l'utilisateur comment créer un événement :</p>

<pre><code class="language-shell">Salut, tu veux créer un événement ? Cool ! 
Commençons, quel est le nom de l'événement ?
> RDV

Super, quand aura-t-il lieu ?
> 2019-01-13 09:00

Au top, combien de temps en minutes va-t-il durer ?
> 30

Génial, qui va participer ? Balance leurs e-mails
> julie@julie.com ; jean@jean.jean

Super, c'est noté, à bientôt !</code></pre>


<h4>2.4.2. DateParser</h4>
<p>Pour la classe <code>EventCreator</code>, ce n'est pas pratique de demander à l'utilisateur une date au format AAAA-MM-JJ HH:MM. Ce serait bien d'avoir une classe qui prend un string en entrée, et qui te sort une jolie en retour. Genre :</p>

<pre><code class="language-ruby">DateParser("lundi prochain à 9h")
#=> 2010-10-31 09:00:00 +0100

DateParser("le 14 octobre à 15h")
#=> 2010-09-14 15:00:00 +0100</code></pre>

<h4>2.4.3. CalendarDisplayer</h4>
<p>Une jolie classe <code>CalendarDisplayer</code> qui prend tous les événements, et qui fait un calendrier en ASCII un peu comme ça :</p>

<pre><code class="language-shell">    Su        Mo        Tu        We        Th        Fr        Sa     
-----------------------------------------------------------------------
|         |1        |2        |3        |4        |5        |6        |
|         |         |         |         |         |9:00am   |         |
|         |         |         |         |         |Sandbox  |         |
|         |         |         |         |         |calendar |         |
|         |         |         |         |         |challenge|         |
-----------------------------------------------------------------------
|7        |8        |9        |10       |11       |12       |13       |
|         |         |9:00am   |10:00am  |         |         |         |
|         |         |Post     |Profit   |         |         |         |
|         |         |challenge|         |         |         |         |
|         |         |to main  |         |         |         |         |
-----------------------------------------------------------------------
|14       |15       |16       |17       |18       |19       |20       |
|         |         |         |         |         |         |         |
|         |         |         |         |         |         |         |
|         |         |         |         |         |         |         |
|         |         |         |         |         |         |         |
-----------------------------------------------------------------------
|21       |22       |23       |24       |25       |26       |27       |
|         |         |         |         |         |         |         |
|         |         |         |         |         |         |         |
|         |         |         |         |         |         |         |
|         |         |         |         |         |         |         |
-----------------------------------------------------------------------
|28       |29       |30       |31       |         |         |         |
|         |         |         |7:30pm   |         |         |         |
|         |         |         |Halloween|         |         |         |
|         |         |         |party    |         |         |         |
|         |         |         |         |         |         |         |
-----------------------------------------------------------------------</code></pre>

<h4>2.4.4. Et plein d'autres</h4>

<p>Bref, plein de fonctionnalités qui mettront Outlook à genou. L'objectif est que tu comprennes l'intérêt de la décomposition par classes, qui permet une grande liberté dans ton programme.</p>

<p>Si jamais tu t'ennuies, fais plus de tests pour tester les méthodes dans ta classe.</p>

<h2>3. Rendu attendu</h2>
<p>Le repo avec les classes remplies. Il faut 2 tests, un par classe.</p>
          </div>
        </div>
        </div>
      </div>
    </div>
  </div>
</div>



</div>


  </div>
</div>
    <script src="/packs/dashboard-031178fac0de4f91cbcc.js"></script>
    

    <script charset="utf-8">
      $('input[name=authenticity_token]').val($('meta[name=csrf-token]').attr('content'));
    </script>

  </body>
</html>
