<!DOCTYPE html>
<html class="loading" lang="fr">
  <head>
    <meta charset="utf-8">
    <link rel="stylesheet" type="text/css" href="../../style/bootstrap.css">
    <title>The hacking project offline</title>
  </head>
  <body class="vertical-layout vertical-menu 2-columns  menu-expanded fixed-navbar" data-open="click" data-menu="vertical-menu" data-color="bg-gradient-x-primary-blue" data-col="2-columns">
      <nav class="navbar navbar-expand-lg navbar-dark bg-primary">
        <h1 class="navbar-brand">THE HACKING PROJECT</h1>
        <button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarColor01" aria-controls="navbarColor01" aria-expanded="false" aria-label="Toggle navigation">
          <span class="navbar-toggler-icon"></span>
        </button>

        <div class="collapse navbar-collapse" id="navbarColor01">
          <ul class="navbar-nav mr-auto">
            <li class="nav-item active">
              <a class="nav-link" href="../../">Home</a>
            </li>
            <li class="nav-item">
              <a class="nav-link" href="../../features">Features</a>
            </li>
            <li class="nav-item">
              <a class="nav-link" href="../../about">About</a>
            </li>
          </ul>
          <form class="form-inline my-2 my-lg-0">
            <input class="form-control mr-sm-2" type="text" placeholder="Search">
            <button class="btn btn-secondary my-2 my-sm-0" type="submit">Search</button>
          </form>
        </div>
      </nav>
<div class="container">
    <a type="button" class="btn btn-dark" href="../../semaine_1/">Semaine 1</a>
    <a type="button" class="btn btn-dark" href="../../semaine_2/">Semaine 2</a>
    <a type="button" class="btn btn-dark btn-lg" href="../../semaine_3/">Semaine 3</a>
    <a type="button" class="btn btn-dark" href="../../semaine_4/">Semaine 4</a>
    <a type="button" class="btn btn-dark" href="../../semaine_5/">Semaine 5</a>
    <a type="button" class="btn btn-dark" href="../../semaine_6/">Semaine 6</a> 
</div>
<div class="app-content content">
  <div class="content-wrapper">
    <div class="content-wrapper-before"></div>
    <div class="content-header row"></div>
    
      <div class="container">
    <div class="card">
  <div class="card-header">
    <h4 class="text-center"> Programme jour par jour</h4>
  </div>
  <div class="card-body">
    <div class="text-center">
    <a href="../../semaine_3">
      <button class="btn btn-secondary btn-outline-dark btn mr-4">
        <i class="fa fa-terminal"></i>&nbsp;&nbsp;&nbsp;Lun
      </button>
</a>    <a href="../../semaine_3/jour_2">
      <button class="btn btn-secondary btn-outline-dark btn mr-4">
        <i class="fa fa-code"></i>&nbsp;&nbsp;&nbsp;Mar
      </button>
</a>    <a href="../../semaine_3/jour_3">
      <button class="btn btn-secondary btn-outline-dark btn-lg mr-4">
        <i class="fa fa-desktop"></i>&nbsp;&nbsp;&nbsp;Mer
      </button>
</a>    <a href="../../semaine_3/jour_4">
      <button class="btn btn-secondary btn-outline-dark btn mr-4">
      <i class="fa fa-folder-open"></i>&nbsp;&nbsp;&nbsp;Jeu
      </button>
</a>    <a href="../../semaine_3/jour_5">
      <button class="btn btn-secondary btn-outline-dark btn mr-4">
      <i class="fa fa-bullhorn"></i>&nbsp;&nbsp;&nbsp;Ven
      </button>
</a>    </div>
  </div>
</div>


<div class="app-content content">
  <div class="content-wrapper">
    <div class="content-wrapper-before"></div>
    <div class="content-header row"></div>
    
      
<div class="content-body">
      <h2 class="text-center">MVC - Ruby Version</h2>
      <h4 class="text-center">Programmation Orientée Objet</h4>
  <div class="row">
     <div class="col-xl-3 col-lg-6 col-md-12">
  <div class="card">
    <div class="card-content">
      <div class="card-body">
        <div class="media d-flex">
          <div class="align-self-top">
              <i class="ft-calendar icon-opacity info font-large-4"></i>
          </div>
          <div class="media-body text-right align-self-bottom mt-3">
              <span class="d-block mb-1 font-medium-1"></span>
              <h3 class="info mb-0">
                 Jour 24 / 55</h3>
          </div>
        </div>
        <div class="progress progress-sm mt-1 mb-0 box-shadow-2">
            <div class="progress-bar bg-gradient-x-info" role="progressbar" style="width: 43%" aria-valuenow="25" aria-valuemin="0" aria-valuemax="120">
            </div>
        </div>
      </div>
    </div>
  </div>
 </div>


    <div class="col-xl-3 col-lg-6 col-md-12">
  <div class="card">
    <div class="card-content">
      <div class="card-body">
        <div class="media d-flex">
          <div class="align-self-top">
            <i class="ft-heart icon-opacity danger font-large-4"></i>
          </div>
          <div class="media-body text-right align-self-bottom mt-3">
            <span class="d-block mb-1 font-medium-1">Jokers restant</span>
            <h3 class="danger mb-0">
                3
            </h3>
          </div>
        </div>
      </div>
    </div>
  </div>
</div>

    <div class="col-xl-3 col-lg-6 col-md-12">
    <div class="card">
        <div class="card-content">
            <div class="card-body">
                <div class="media d-flex">
                    <div class="align-self-top">
                        <a href="/dashboard/assignments?locale=fr">
                           <i class="ft-fast-forward icon-opacity warning font-large-4"></i>
</a>                    </div>
                    <div class="media-body text-right align-self-bottom mt-3">
                        <span class="d-block mb-1 font-medium-1">Missions</span>
                            <div class="badge border-danger danger badge-border">Pas inscrit</div>
                    </div>
                </div>
            </div>
        </div>
    </div>
</div>

  </div>
  <div class="row">
        <div class="container">
    <div class="col-xl-12 col-lg-12 col-md-12">
    <div class="card">
        <div class="card-header">
        <h1 >Programmation Orientée Objet
                <i class="fa fa-beer text-warning"></i>
        </h1>
        
        </div>
        <div class="card-content">
        <div class="card-body">
            <div class="card-text">
            <h2 class="text-center">MVC - Ruby Version</h2>
            <div class="cd-horizontal-timeline loaded">
                <div class="timeline">
                <div class="events-wrapper">
                    <div class="events" style="width: 1800px;">
                    <ol>
                                <li>
                                    <a style="left:120px;" href="/dashboard/weeks/3/days/1?locale=fr">
                                        Lun
                                            <i class="fa fa-beer text-warning" aria-hidden="true" data-toggle="tooltip" data-placement="bottom" title="Rendez-vous pour boire un coup"></i>

</a>                                </li>
                                <li>
                                    <a style="left:240px;" href="/dashboard/weeks/3/days/2?locale=fr">
                                        Mar
                                            <i class="fa fa-rocket text-danger" aria-hidden="true" data-toggle="tooltip" data-placement="bottom" title="Projet à rendre ce jour-là"></i>

</a>                                </li>
                            <li>
                                <a class="selected" style="left:360px;" data-toggle="tooltip" data-placement="top" title="MVC - Ruby Version" href="/dashboard/weeks/3/days/3?locale=fr">
                                    Mer
                                        <i class="fa fa-pencil text-success" aria-hidden="true" data-toggle="tooltip" data-placement="bottom" title="Corrections cette journée là" ></i>


</a>                                </li>
                                <li>
                                    <a style="left:480px;" href="/dashboard/weeks/3/days/4?locale=fr">
                                        Jeu
                                            <i class="fa fa-rocket text-danger" aria-hidden="true" data-toggle="tooltip" data-placement="bottom" title="Projet à rendre ce jour-là"></i>

</a>                                </li>
                                <li>
                                    <a style="left:600px;" href="/dashboard/weeks/3/days/5?locale=fr">
                                        Ven
                                            <i class="fa fa-pencil text-success" aria-hidden="true" data-toggle="tooltip" data-placement="bottom" title="Corrections cette journée là" ></i>


</a>                                </li>
                    </ol>
                </div>
                </div>
            </div>
            </div>
        </div>
        </div>
    </div>
    </div>
<div>
  </div>

  <!-- Les fameuses corrections qui n'arrivnet que les jours concernés -->


    <div class="container">
  <div class="row">
    <div class="col-12">
      <div class="card">
        <div class="card-header" style="border-top: 3px solid #5E66E5 " >
          <h1>Cours : MVC</h1>
          <a class="heading-elements-toggle">
          <i class="la la-ellipsis-v font-medium-3"></i>
          </a>
          <div class="heading-elements">
            <ul class="list-inline mb-0">
              <li><a data-action="collapse"><i class="ft-minus"></i></a></li>
              <li><a data-action="expand"><i class="ft-maximize"></i></a></li>
            </ul>
          </div> 
      </div>
      <div class="card-content collapse show">
        <div class="card-body">
          <div class="tab-pane active" id="home1" role="tabpanel">
          
<h3>1. Introduction</h3>
<p>Dans cette ressource, tu vas voir ce qu'est que la fameuse architecture MVC. Nous t'expliquerons ce qu'elle veut dire, comment s'en servir, où elle est utilisée, et enfin pourquoi l'utiliser.</p>

<p>Si l'on devait résumer le MVC en une phrase, la voici : <br>
<b>le MVC, acronyme de Model-View-Controller, est un modèle d'architecture de logiciel orienté objet qui le décompose en 3 grosses composantes : une qui gère l'accès à la base de données (Model), une qui gère les interactions avec l'utilisateur (View), et une qui fait le rôle de chef d'orchestre de tout cela (Controller)</b>.</p>

<h3>2. Historique</h3>
<p>Avec la complexification constante des programmes dans les années 70, les informaticiens se sont dit que ranger le code dans des dossiers bien foutus, ça ne suffisait plus. Il fallait trouver une convention pour découper un gros programme en briques logiques (des sous-programmes) afin que ce soit plus lisible et moins le bordel. C'est là qu'intervint Trygve Reenskaug.</p>

<p>En 1978, lors d'une visite au très célèbre <a href="https://fr.wikipedia.org/wiki/Palo_Alto_Research_Center" class="text-primary" target="_blank">Palo Alto Research Center</a> (PARC), l'informaticien norvégien y présenta un modèle d'architecture logicielle adapté à leur concept naissant d'interface graphique (ça n'existait pas encore à l'époque). Ce premier jet de l'architecture MVC concernait un langage de programmation orienté objet qui s'appelle SmallTalk. Citons-le lors de la création du MVC : </p>

<blockquote class="blockquote pl-1 border-left-primary border-left-3">
  <p class="mb-0">MVC was conceived as a general solution to the problem of users controlling a large and complex data set. The hardest part was to hit upon good names for the different architectural components. Model-View-Editor was the first set. After long discussions, particularly with Adele Goldberg, we ended with the terms Model-View-Controller.</p>
  <footer class="blockquote-footer">Trygve Reenskaug</footer>
</blockquote>

<p>Le modèle du MVC connut un grand succès vers le milieu des années 90 avec l'introduction de WebObjects. Java s'y est mis plus tard, ce qui a aidé à sa popularité. Enfin, le milieu des années 2000 a vu sa popularité croître auprès de cibles moins "corpo" puisque la création de Django en juillet 2005 (basé sur un modèle très proche, le MTV) et de Ruby on Rails en décembre 2005 ont permis au MVC de passer au rang de superstar dans l'architecture logicielle du web.</p>

<p>Aujourd'hui, le MVC est le framework d'architecture de sites le plus utilisé sur Internet.</p>

<h3>3. La ressource</h3>
<h4>3.1. Pourquoi se servir du MVC ?</h4>
<p>Imagine que tu fais une application complexe qui envoie des e-mails aux mairies. Nous pourrions écrire tout le code dans un fichier qui s'appelle <code>townhall_email.rb</code>. Le souci est que ce fichier se retrouverait avec beaucoup trop de lignes, et travailler à plusieurs dessus serait vite complexe. Maintenant imagine un projet encore plus grand, comme le site web de The Hacking Project. Il est hors de question d'avoir un fichier app.rb qui fait 200 000 lignes : le maintenir serait l'enfer sur Terre. OK, mais comment le découper ? Faire 1 classe pour 1 fonctionnalité, ne suffit généralement pas.</p>

<p>C'est pour cela que les architectures logicielles ont été créées : pour découper son programme en différents fichiers bien rangés selon un schéma précis. Ainsi, sans même avoir à lire le code de chaque fichier, on peut savoir globalement son rôle dans le programme. Il existe plusieurs façons d'architecturer une application, mais pour le web, le MVC est très populaire. <br>
À partir de maintenant, ne te laisse plus impressionner quand on te parle d'architecture logicielle : il s'agit juste de découper intelligemment un programme en plein de sous-programmes…</p>

<p>Une fois l'architecture choisie, le code de ton programme est alors rangé dans plein de fichiers rangés en catégories, chacun a son utilité, et il est alors facile (quand on connaît le framework) de savoir lequel modifier dans un cas donné.</p>

<h4>3.2. Model - View - Controller</h4>
<p>Voici un schéma qui représente le fonctionnement de l'archi MVC :</p>
<img src="https://i.imgur.com/411m4Ch.png" class="img-fluid">
<h5>Étape 1 : Le Routeur</h5>

<p> L'utilisateur va aller sur l'application en saisissant une URL (= une adresse web). Le routeur, qui reçoit cette URL, s'occupe de router (Tiens ! Comme son nom est bien choisi !) l'utilisateur vers le bon endroit, à l'image d'un aiguilleur qui dirigerait un train vers la bonne route. Par exemple, si l'utilisateur va sur la page facebook.com/mes_messages, le routeur va rediriger sa requête au controller qui s'occupe d'afficher tout ce qui est relatif aux messages. Si l'utilisateur était allé sur facebook.com/mon_profil, le routeur aurait redirigé la requête au controller qui s'occupe d'afficher ce qui est relatif aux profils.</p>
<p>Donc <b>le routeur redirige l'utilisateur vers le bon controller (qui n'est autre qu'une classe Ruby)</b>. <br>
  Mais plusieurs URLs peuvent pointer vers un même controller. Par exemple toutes les URLs suivantes vont pointer vers le controller en charge d'afficher ce qui est relatif aux messages : 
  <ul>
    <li>facebook.com/mes_messages => affichage des messages reçus</li>
    <li>facebook.com/nouveau_message => rédaction d'un message</li>
    <li>facebook.com/messages_envoyés => affichage des messages envoyés</li>
  </ul>  
  Du coup, le routeur va devoir être plus spécifique que de simplement pointer vers un controller. Au final, il va rediriger l'utilisateur vers une méthode <u>précise</u> du controller des messages.</p>

<h5>Étape 2 : Le Controller</h5>
<p>En poursuivant sur l'exemple de la page facebook.com/mes_messages : l'utilisateur va s'attendre, en tapant cette URL, à voir s'afficher sur son navigateur tous les messages de sa boite de réception. <br>
  Il saisit l'URL, le routeur l'analyse et le renvoie vers une méthode précise du controller des messages : la méthode <code>show_messages</code>. Cette méthode aura 2 rôles qui résument bien la raison d'être d'un controller :
<ol>
  <li>Récupérer les informations de la base de données qu'il faut afficher (la liste des messages avec leur titre, l'expéditeur, la date de réception, etc.). <b>Pour cela, il va faire une demande au model, dont le rôle est d’interagir avec la base de données</b>.</li>
  <li>Une fois les informations récupérées du model, <b>le controller les envoie à la view correspondant à la méthode <code>show_messages</code></b>. Cette view va construire une jolie page HTML qui sera renvoyée à l'utilisateur.</li>
</ol></p>

<h5>Étape 3 : Le Model</h5>
<p> Le model est une autre classe Ruby qui va avoir pour rôle d'interagir avec la base de données sur demande du controller. Généralement, il s'agit pour lui de récupérer des informations (qui doivent ensuite être affichées à l'utilisateur) sous la forme d'objets. Par exemple pour la page facebook.com/mes_messages, le controller va demander au model <code>Message</code> de lui retourner une liste des objets de la classe Message en ne sélectionnant que ceux doivent apparaître dans la boite de réception de l'utilisateur. <b>Le Modèle va piocher dans la base de données et renvoyer des objets de la classe <code>Message</code>, chacun étant lié à ses variables d'instance, par exemple un texte, un titre, un expéditeur, une date d'envoi, etc.</b></p>

<p>Un autre cas fréquent est qu'un controller demande au modèle de créer un message en base de données. C'est encore le model qui va s'occuper de cela, via une requête SQL qui n'aura même pas à être codée par vous (c'est là toute l'utilité du model).</p>

<p>Une fois l'opération effectuée par le model, le controller reprend la main. Dans notre exemple sur facebook.com/mes_messages, le model va renvoyer un array <code>@messages</code> qui contient tous les objets de classe <code>Message</code> qu'il faut afficher dans la boite de réception.</p>

<h5>Étape 4 : La View</h5>
<p>Une fois que le controller a toutes les informations à afficher, il les rend disponibles à une dernière classe Ruby : la view. Celle-ci a pour rôle de <b>construire du HTML avec les informations envoyées par le controller</b>, HTML qui sera ensuite affiché sur le navigateur web de notre utilisateur. Dans notre exemple, si le controller nous envoie l'array <code>@messages</code>, la view pourra facilement parcourir cet array avec un petit <code>@messages.each do</code> et pour chaque objet de classe <code>Message</code> contenu dans l'array, elle va afficher une ligne dans la boite de réception de notre utilisateur.</p>

<p>Le controller peut rendre plusieurs objets disponibles à la view (tant qu'il en a fait la demande au bon model). Ainsi, on aurait pu avoir un objet <code>@current_user</code> de classe <code>User</code> qui correspond à l'utilisateur actuellement connecté. Avec cet objet, la view peut afficher facilement un <code>@current_user.name</code> qui retourne son nom et permet d'écrire un truc du genre <code>"Voici ta boite de réception Félix !"</code>.</p>

<p>Une fois la page HTML affichée, le tour est joué ! Il ne reste plus qu'à attendre un clic de l'utilisateur sur un lien. En cliquant, il indique "je veux aller sur cette URL" => l'URL est envoyée au routeur => le routeur renvoie vers la bonne méthode du bon controller => etc. La boucle est bouclée, la routourne a tourné. </p>

<h5>En résumé</h5>

<p>Le routeur redirige, en fonction de ce que fait l'utilisateur (= quelle URL il choisit) vers la bonne méthode du bon controller (= le chef d'orchestre de tout cela). Puis le controller va demander à un model de récupérer en base de données les informations nécessaires. Ces informations sont ensuite renvoyées à une view pour qu'elle puisse construire la page HTML qu'on envoie à notre utilisateur. </p>


<div class="card box-shadow-0 border-success">
  <div class="card-content collapse show">
    <div class="card-body">
      <h4 class="card-title">🎨 EXEMPLE ILLUSTRÉ</h4>
      <p class="card-text">Pour bien visualiser le modèle MVC, on va te donner un exemple concret : celui d'un restaurant et de ses employés.
      <ul>
        <li>Le manager du restau (qui veut tout valider et tout savoir) : c'est le Controller ;</li>
        <li>La cuistot serait le Model ;</li>
        <li>Le serveur qui apporte les plats, serait la View ;</li>
        <li>La serveuse qui présente le menu et prend les commande, serait le Routeur.</li>
      </ul>
      Tu entres dans le restaurant et t'assois à une table : la serveuse-Routeur vient alors te présenter le menu et prend ta commande. <br>Elle transmet l'info au manager-Controller (oui, ce manager veut TOUT savoir). Le Controller va alors demander au cuistot-Model de préparer le plat demandé. <br>
      Une fois fait, le Model donnera le plat au Controller, qui ordonnera au serveur-View de vous l'apporter. <br>
      Une fois le plat consommé, vous pouvez éventuellement vouloir continuer le repas : la serveuse reviendra avec le menu, etc.</p>
    </div>
  </div>
</div>

<h4>3.3 Quelques règles de base pour bien réussir vos Model - Controller - View</h4>
<p>On va te donner quelques règles à avoir en tête quand tu construiras un programme en MVC. Pour le moment cela ne te servira pas, mais c'est bien de s'en imprégner au début : </p>

<ul>
  <li>Le MVC a une philosophie de "fat models, skinny controllers". C’est-à-dire qu'il est préférable de faire des controllers avec le moins de code possible, quitte à tout mettre dans le model.</li>
  <li>Les controllers (qui sont des classes Ruby) seront remplis de méthodes. Il faut au maximum que ces méthodes correspondent à celles d'un "CRUD" (Create, Read, Update, Destroy) et éviter d'en rajouter d'autres, quitte à créer plus de controllers. </li>
  <li>Il faut que ton code soit DRY (Don't Repeat Yourself) : n'écrit jamais plus de deux fois la même chose… Au bout de la 3ème fois, c'est que le bout de code que tu répètes peut être mis dans un endroit (une méthode par exemple) auquel tu fais appel en une seule ligne. </li>
  <li> Le DRY est primordial pour les views. La majorité du temps, les views utilisent du code qui est répété à plusieurs endroits. Par exemple le header ou le footer, que l'on retrouve partout, peuvent être mis dans un fichier "header" et être appelé en une ligne par chaque view.</li>
  <li>Comme les models jouent avec la base de données, et qu'une base de données propre est crucial pour toute application web, la construction des models peut prendre beaucoup de temps comparé au reste. Bâcler ses models, c'est aller au-devant de gros problèmes à moyen terme.</li>
</ul>

<p>Nous reviendrons plus tard sur ces règles de base.</p>

<h3>4. Points importants à retenir</h3>
<p>Le MVC a été créé afin de pouvoir gérer des interfaces graphiques et des bases de données. C'est un modèle d'architecture logicielle utilisé par la majorité des sites internet. Il ne peut être appliqué qu'aux langages orientés objets.</p>

<p>MVC veut dire Model View Controller : il décomposera ton app en trois grosses composantes.</p>
<ul>
  <li>une qui gère la base de données (Model) – en y ajoutant, supprimant ou récupérant les bonnes informations.</li>
  <li>une qui gère les interactions avec l'utilisateur (View) – en construisant les pages HTML.</li>
  <li>une qui fait le rôle de chef d'orchestre de tout cela (Controller) – en faisant le lien entre chaque composant.</li>
</ul>

<p>Le routeur redirige, en fonction de ce que fait l'utilisateur (= quelle URL il choisit) vers la bonne méthode du bon controller (= le chef d'orchestre de tout cela). Puis le controller va demander à un model (= classe Ruby faisant des requêtes) de récupérer en base de données les informations nécessaires. Ces informations sont ensuite renvoyées à une view pour qu'elle puisse construire la page HTML.</p>

<h3>5. Pour aller plus loin</h3>
<p>Le projet du jour va concerner une application Ruby en MVC, mais si tu t'ennuies, tu peux aller jeter un oeil à <a href="https://github.com/mindplace/ruby-todo-list" class="text-primary" target="_blank">ce repo GitHub</a>, où Esther a créé une application de To-Do List en Ruby, utilisant le modèle du MVC.</p>

          </div>
        </div>
        </div>
      </div>
    </div>
  </div>
</div>


  <div class="container">
  <div class="row">
    <div class="col-12">
      <div class="card">
        <div class="card-header" style="border-top: 3px solid #FF4081 " >
          <h1>Projet : The Gossip Project - The MVC POO version</h1>
          <a class="heading-elements-toggle">
          <i class="la la-ellipsis-v font-medium-3"></i>
          </a>
          <div class="heading-elements">
            <ul class="list-inline mb-0">
              <li><a data-action="collapse"><i class="ft-minus"></i></a></li>
              <li><a data-action="expand"><i class="ft-maximize"></i></a></li>
            </ul>
          </div> 
      </div>
      <div class="card-content collapse show">
        <div class="card-body">
          <div class="tab-pane active" id="home1" role="tabpanel">
          <h3>1. Introduction</h3>
<p>La théorie, c'est bien. La pratique, c'est mieux. Nous allons donc te proposer de mieux appréhender l'architecture du MVC en faisant une application Ruby. Cette application utilisera bien entendu le modèle du MVC, afin d'avoir du code propre, bien rangé, et bien ordonné. Le projet sera un peu plus pas à pas que d'habitude. C'est normal, étant donné que son premier MVC n'est jamais aisé.</p>

<p>Voici l'application : The Hacking Project est une superbe formation, avec une communauté soudée. Qui dit communauté soudée, dit potins à tout-va. Nous allons donc créer une application qui s'appelle The Gossip Project, où l'utilisateur pourra rentrer les ragots et rumeur, afficher une liste des potins, puis de supprimer ceux qui ne sont plus d'actualité.</p>

<p>Les vues seront faites dans le terminal, les potins enregistrés en CSV, et le programme tournera jusqu'à ce que l'utilisateur le quitte.</p>

<p>Pour cet exercice, j'ai fait le choix de CSV, mais tu peux remplacer CSV par JSON si tu es plus à l'aise. Il faudra juste garder la même arborescence et la même logique. Maintenant que c’est dit, nous pouvons commencer.</p>

<h3>2. Le projet</h3>
<p>Note pour les tests : aujourd'hui pas de tests. On veut pas t'assommer avec trop d'info.</p>

<h4>2.1. Décomposer le programme</h4>
<p>Avant de partir dans du code sans réfléchir, nous allons penser et conceptualiser le programme. Il y aura 4 grandes parties, chacune correspondant à une classe (donc un fichier) :</p>
<ul>
  <li>Le routeur</li>
  <li>Le controller</li>
  <li>La view</li>
  <li>La base de donnée (model)</li>
</ul>

<h5>2.1.1. Le routeur</h5>
<p>Le travail du routeur sera simple : c'est de demander ce que l'utilisateur veut faire. Il aura 3 choix : créer un gossip, voir la liste des gossips ou supprimer un gossip. En fonction, le routeur pointera vers la bonne méthode du controller.</p>

<h5>2.2.2. Le controller</h5>
<p>Le controller servira de relai entre la view et le model. Il aura 3 méthodes : une qui gère la création d'un potin, une qui gère l'affichage de la liste des potins, et une qui permet de détruire un potin. Chaque méthode devra faire le lien avec le model et la view.</p>
<h5>2.1.3. La view</h5>
<p>La view s'occupera d'afficher les bonnes informations à l'utilisateur. Comme on n'a pas encore vu les systèmes de fichiers HTML (on voit ça très bientôt 😉), on va coder ça sur le terminal avec des bons vieux <code>puts</code> en l'affichage et <code>gets.chomp</code> pour obtenir les ordres de l'utilisateur.</p>

<h5>2.1.4. Le model et la base de données</h5>
<p>Un potin sans son contenu, eh bien c'est comme un hamburger sans pain. Vazy cé nul. Nous allons donc faire en sorte qu'un potin ait 2 attributs :</p>
<ul>
  <li>son <code>content</code> qui est un string</li>
  <li>un <code>author</code> qui est aussi un string</li>
</ul>

<p>C'est tout. On aurait pu ajouter d'autres choses (la date du potin par exemple), mais pour ce premier MVC on va faire simple.</p>

<p>Au final, le model sera une classe <code>Gossip</code> qui ira piocher dans la base de données (le CSV) et sortira des instances de <code>Gossip</code>. Ces objets de type <code>Gossip</code> auront, tu l'as compris, 2 variables d'instance : un <code>content</code> et un <code>author</code>.</p>

<h5>2.1.5. Architecture du programme</h5>
<p>Ok, en sachant tout ceci, notre arborescence du programme va ressembler, à la fin, à ça :</p>
<pre><code class="language-shell">.
├── lib
│    ├── controller.rb
│    ├── gossip.rb
│    ├── router.rb
│    └── view.rb
├── db
│   └── gossip.csv
├── app.rb
├── Gemfile
└── Gemfile.lock</code></pre>

<p>Jusqu'ici, rien de bien nouveau. Pour y parvenir, commençons par le commencement, la première fonctionnalité : l'ajout de potins.</p>

<h4>2.2. Ajouter un potin</h4>
<p>Poser les bases d'un programme, sa structure, c'est toujours le gros morceau. Pour t'éviter le syndrome de la page blanche, nous allons te guider dans ta quête du potin parfait.</p>

<h5>2.2.1. Les préparations</h5>
<p>Avant toute chose, tu vas créer un dossier <code>the_hacking_gossip_ruby_version_POO</code> puis te placer dedans. Tu vas ensuite créer le Gemfile, mettre la bonne version de Ruby, la gem CSV, puis tes gems préférées (PRY pourra t'aider par exemple), et faire l'installation via Bundler.</p>

<p>Puis nous allons faire le fichier <code>app.rb</code>, porte d'entrée de notre application. Étant donné que tout passe par le router, il faut juste que son code fasse appelle à la classe <code>Router</code> via un <code>Router.new.perform</code> et puis c'est tout 👈</p>

<p>Par contre, une fois écrit, si tu lances ton programme, ce dernier devrait t'envoyer bouler puisque tu n'as pas encore créé ta classe Router. C'est la prochaine étape.</p>

<p>L'arborescence à l'instant T ressembler à ceci : </p>

<pre><code class="language-shell">.
├── app.rb
├── Gemfile
└── Gemfile.lock</code></pre>
    

<h5>2.2.2. Le router</h5>
<p>Le boulot du router est proche de celui d'un serveur : il propose les possibilités à notre utilisateur, et en fonction de ce que celui-ci rentre, il redirige vers la bonne méthode du controller. ✌</p>

<p>Dès le début, le router va créer une instance de la classe <code>Controller</code> qu'on appellera <code>@controller</code>. C'est un peu déroutant mais c'est via cette instance qu'il va déclencher la méthode adéquate : celle qui permet d'ajouter un potin, de le supprimer ou de les lister tous. Dans ce cas précis, l'instance <code>@controller</code> ne te parle pas trop en termes d'objet, car on ne peut pas la rattacher à un objet concret (comme un gossip, un user ou une voiture). Dis-toi juste que c'est une manière pour le routeur d'exécuter une méthode d'une autre classe. En faisant <code>@controller.create_gossip</code>, il passe la main à la classe <code>Controller</code> en exécutant la méthode <code>create_gossip</code></p>

<p> Première étape donc : appeler la classe Controller avec <code>require</code>, et l'instancier (= créer une instance) à l'initialize. C'est beaucoup de termes techniques, mais cela permet de commencer à bien te familiariser avec les concepts de POO. D'une pierre deux coups ⚡</p>

<p>Ensuite, dans la méthode <code>perform</code>, le router va faire une boucle infinie (boucle <code>while true</code>)qui va demander ce que l'utilisateur veut faire en lui donnant plusieurs choix (on utilise ici un <code>case - when</code>, va voir sur Google comment ça marche si besoin). Puisque c'est toi, nous allons te donner le code du routeur : </p>

<pre><code class="language-ruby">require 'controller'

class Router

  def initialize
    @controller =  Controller.new
  end #ainsi, un "Router.new" lancé par app.rb va créer automatique une instance "@controller"

  def perform #rappelle-toi que l'on fait "Router.new.perform" dans app.rb => après initialize, on définit perform.
    puts "BIENVENUE DANS THE GOSSIP PROJECT"
    while true

      #on affiche le menu
      puts "Tu veux faire quoi BG ?"
      puts "1. Je veux créer un gossip"
      puts "4. Je veux quitter l'app"
      params = gets.chomp.to_i #on attend le choix de l'utilisateur

      case params #en fonction du choix
      when 1
        puts "Tu as choisi de créer un gossip" 
        @controller.create_gossip
      when 4
        puts "À bientôt !"
        break #ce "break" permet de sortir de la boucle while. C'est même la seule façon d'en sortir.
      else
        puts "Ce choix n'existe pas, merci de ressayer" #si l'utilisateur saisit une entrée non prévue, il retourne au début du "while true". C'est pour ça que la boucle est infinie: potentiellement, il peut se gourer jusqu'à la fin des temps :)
      end
    end
  end
end</code></pre>

<p>Une question qui demande ce que l’utilisateur veut faire, un bon vieux case, et les bonnes redirections. C'est aussi simple que cela. Maintenant si tu lances le programme, ce dernier va râler, car le controller n'existe pas. C'est bon signe puisque cela veut dire qu'il arrive à lire le router, mais ce n'est pas encore ce que nous voulons. On va créer le controller, et commencer à avoir un début de programme. En avant !</p>

<p>À ce moment-là, ton code devrait ressembler à ceci :</p>
<pre><code class="language-shell">.
├── app.rb
├── Gemfile
├── Gemfile.lock
└── lib
    └── router.rb</code></pre>

<h5>2.2.3. Le controller</h5>
<p>Ce fameux chef d'orchestre. Étant donné que le controller joue avec le model et la view, tu vas devoir les <code>require</code> au début du programme. Pour le moment la méthode <code>create_gossip</code> va juste s'amuser à créer un nouvel objet Gossip avec <code>Gossip.new</code>. Nous verrons commencer pointer vers la view plus tard 😉</p>

<p>Idem, si tu testes ton programme, il devrait t'envoyer bouler comme d'hab, en disant que le fichier gossip n'existe pas. C'est parti, créé ton fichier gossip.rb et nous allons créer en base les potins.</p>

<h5>2.2.4. Le model</h5>
<p>La classe <code>Gossip</code>, qui constituera le model, va permettre de créer plein d'instances qui seront autant de potins : enfin on revient à un exemple de classe qui héberge des objets concrets ! Mais le model aura aussi pour rôle d’interagir avec la base de données. Par exemple, pour la création, nous allons faire une méthode <code>save</code> qui ira sauvegarder dans un fichier CSV notre instance de Gossip (notre potin quoi). Cela peut faire peur, mais c'est juste quelques lignes de code.</p>

<p>Déjà, notre potin aura deux variables d'instance qu'on mettra en <code>attr_reader</code> : ce seront le <code>author</code> et le <code>content</code>. Ces attributs seront déclarés à l'initialisation de façon classique :</p>

<pre><code class="language-ruby">def initialize(author, content)
  @content = content
  @author = author
end</code></pre>

<p>On te laisse mettre les <code>attr_reader</code> aussi 🙃</p>

<p>Bon, grâce à ce code, on a la possibilité de faire <code>Gossip.new(author, content)</code>. C'est un bon début, mais cela ne sauvegarde rien du tout dans notre CSV. il faudrait donc une méthode <code>save</code> qui enregistrerait dans la base de donnée l'instance de potin que l'on vient de créer. Nous allons faire cela.</p>

<p>En gros, le fonctionnement du model se passerait ainsi :</p>
<pre><code class="language-ruby">my_gossip = Gossip.new(author, content) #=> Créé une instance de potin, sauvergardée juste dans cette variable
my_gossip.save #=> Sauvegarde l'instance de potin dans le CSV correspondant, en créant une nouvelle ligne dans mon fichier CSV</code></pre>

<p>Notre base de données de potins sera rangée dans un fichier <code>gossip.csv</code> qui se trouve dans un dossier <code>db/</code> (cf. l'arborescence donnée au début). Chaque ligne correspond à un potin, avec en colonne 1 le <code>author</code> et en colonne 2 le <code>content</code>.</p>

<p>Maintenant, je t'invite à faire en sorte que lorsque l'on fait <code>save</code>, cela va créer une <b>nouvelle</b> ligne (sans tout effacer !) dans le CSV qui contiendra en colonne 1 le <code>author</code> et en colonne 2 le <code>content</code> (séparés par une virgule donc, c'est le principe du CSV).</p>

<h5>2.2.5. Retour rapide au controller</h5>
<p>Maintenant que le model est capable de créer un gossip et de le sauvegarder, retouche la méthode <code>create_gossip</code> dans le controller en y ajoutant les lignes suivantes :</p>

<pre><code class="language-ruby">gossip = Gossip.new("Jean-Michel Concierge", "Féfé est de Bordeaux") #pour le moment, le contenu du gossip est en dur dans le code. L'utilisateur ne peut pas le changer.
gossip.save</code></pre>

<p>Si tout est bien branché, tu devrais voir apparaître une ligne dans ton CSV avec ces paramètres dès que tu rentres <code>1</code> dans ton routeur. Ce qui, quand on y pense, est un super début : tu as réussi à brancher tout seul comme un grand un routeur, un controller, et le lier à la base de données. Je n'ai quasiment rien fait. Joli 😘</p>

<p>Évidemment, ce n'est pas encore fini, puisqu'il faut pouvoir rentrer les potins en base de manière interactive. Eh bien la view va s'occuper de gérer cela !</p>

<h5>2.2.6. La view</h5>
<p>La view est appelée du controller. Il faut donc l'instancier à partir du controller pour rediriger vers elle. Nous allons donc require le fichier view (qui contiendra la classe <code>View</code>) à partir du controller, puis faire un petit <code>@view = View.new</code> à l'initialisation du controller. Enfin, il suffira d'appeler la view dans la méthode <code>create_gossip</code> en ajoutant la ligne suivante : <code>params = @view.create_gossip</code>. Et oui, pour ne pas nous emmêler trop les pinceaux, on va se débrouiller pour que la méthode <code>create_gossip</code> de la classe <code>Controller</code> soit liée à une méthode éponyme <code>create_gossip</code> de la classe <code>View</code>. Comme ça c'est facile de s'en rappeler.</p>

<p>Ainsi, nous disons au controller d'exécuter la méthode <code>create_gossip</code> de la view afin de récupérer les infos de l'utilisateur (= le contenu et l'auteur du nouveau gossip).</p>

<p>Évidemment, si tu testes le programme, ce dernier va te saouler, car il faut créer le fichier view.rb. Ça commence à être relou, MAIS ce sera la dernière fois aujourd'hui que tu vas faire cela. Génial, non ? Une fois le fichier créé, l'arborescence de ton dossier devrait être identique à l'arborescence que j'avais proposée au début. Tu n'auras plus qu'à créer les méthodes et faire les bons appels.</p>

<p>Alors réflechissons. Que voulons-nous que la méthode <code>create_gossip</code> de la classe <code>View</code> fasse ? Elle doit demander deux variables (l'auteur et le contenu) à l'utilisateur (via <code>puts</code> et <code>gets.chomp</code>), puis faire return sur ces deux variables. C'est tout.</p>

<p>Pour le return des variables, je t'invite à le faire sous la forme d'un hash : <code>return params = { content: content_que_tu_viens_de_demander, author: author_que_tu_viens_de_demander }</code>. Pourquoi comme ceci ? Eh bien en général pour les interactions avec les utilisateurs, dans le web on utilise une variable qui s'appelle <code>params</code> et qui est sous le format hash. Et c'est bien d'avoir dès le début les bons termes. <br>
Bien entendu, tu aurais pu enlever <code>params =</code> ce qui aurait donné exactement le même résultat (une méthode retourne le contenu d'une variable, pas son nom), mais c'est pour plus de clarté, ce qui n'est jamais de refus quand on débute 😇</p>
<p>Je te laisse coder la méthode <code>create_gossip</code> de la classe <code>View</code></p>

<h5>2.2.7. Retour au controller</h5>
<p>Encore ? Eh oui, le controller est le chef d'orchestre, donc c'est normal d'y faire des aller-retours ! Maintenant, si ton programme est bien branché, la méthode <code>create_gossip</code> de <code>Controller</code> devrait avoir à sa disposition une variable <code>params</code> qui est un hash qui contient les informations que tu veux. </p>

<div class="card box-shadow-0 border-info">
  <div class="card-content collapse show">
    <div class="card-body">
      <h4 class="card-title">🚀 ALERTE BONNE ASTUCE</h4>
        <p>Galère de variable mal placée ? Tu ne sais pas trop comment jouer avec <code>params</code> ? N'oublie pas ma phrase préférée : "dans le doute, fous des <code>puts</code>". Et n'hésite pas à faire plein de tests avec PRY, très pratique pour jouer avec des variables récalcitrantes.</p>
    </div>
  </div>
</div>


<p>Maintenant, injecte les valeurs de ton hash <code>params</code> dans le <code>Gossip.new(author, content)</code>, et à toi la gloire !</p>

<h5>2.2.8. Création terminée !</h5>
<p>Waow ! Tu as réussi à faire –presque– tout seul une création de potin en MVC ! Si c'est pas la classe ça, <i>I don't know what it is</i> 😎</p>

<p>Maintenant, on va pouvoir s'éclater avec la suite : nous allons pouvoir afficher tous les potins, puis évidemment supprimer de la base les potins qui ne sont plus d'actualité. C'est parti !</p>

<h4>2.3. Afficher les potins</h4>
<p>Cette partie sera un peu moins pas à pas, mais quand même on va t'aider. Tout d'abord, avant de foncer tête baissée dans le code, nous allons réfléchir à ce qu'il faut.</p>

<p>Nous voudrions pouvoir, quand l'utilisateur le demande, afficher tous les potins en base. Cela veut dire : laisser la possibilité à l'utilisateur de choisir l'option <code>2. Afficher tous les potins</code> via le routeur, ce qui va le rediriger vers la méthode <code>index_gossips</code> de notre controller. La méthode <code>index_gossips</code> va demander au model de lui sortir tous les potins, puis les donner à la view pour qu'elle puisse les afficher. Du MVC dans toute sa splendeur. Allez c'est parti !</p>

<h5>2.3.1. Le router</h5>
<p>C'est la partie la plus simple : il faut pouvoir dire à l'utilisateur qu'il peut choisir <code>2</code>, qui est le numéro pour afficher tous les potins. S'il choisit <code>2</code>, nous allons le rediriger vers la méthode <code>index_gossips</code> de notre controller.</p>

<h5>2.3.2. Le controller</h5>
<p>La méthode <code>index_gossips</code> du controller va faire deux chose :</p>
<ul>
  <li>Demander au model un array qui contient toutes les potins que l'on a en base</li>
  <li>demander à la view d’exécuter sa propre méthode <code>index_gossips</code> qui affichera tous les potins</li>
</ul>

<h5>2.3.3. Le model</h5>
<p>Pour ceci, nous allons utiliser une méthode qui s'appelle <code>self.all</code>, qui va lire chaque ligne du CSV, puis retourner un array contenant des <b>instances</b> de potins du genre : <code>[potin_1, potin_2, …, potin_n]</code>. J'insiste sur un point: il s'agit d'un <b>array d'objets de la classe <code>Gossip</code></b>. Donc si je fais <code>potin_1.author</code>, je récupère l'auteur du potin_1. Si je fais <code>potin_2.content</code>, je récupère le contenu du potin_2. Et ainsi de suite.</p>

<p>Comme ce n'est pas la méthode la plus simple, nous allons te donner le pseudo-code de la méthode <code>self.all</code>, pour t'aiguiller dans la recherche de l'array parfait :</p>

<pre><code class="language-ruby">def self.all
  # création d'une array vide qui s'appelle all_gossips
  # chaque ligne de ton CSV.each do |ligne|
    # gossip_provisoire = Gossip.new(paramètres de la ligne) - permet de créer un objet gossip
    # all_gossips &lt;&lt; gossip_provisoire - permet de rajouter cet objet au array
  # end
  # return all_gossips - on renvoie le résultat
end</code></pre>

<div class="card box-shadow-0 border-success">
  <div class="card-content collapse show">
    <div class="card-body">
      <h4 class="card-title">🤓 QUESTION RÉCURRENTE</h4>
      <p><b>Mais dis donc Jamy, c'est quoi la différence entre <code>def truc</code> et <code>def self.truc</code> ?</b> Excellente question car cela peut porter à confusion la première fois qu'on l'utilise.</p>
      <p>On en a parlé dans le cours de POO: une méthode <code>self.truc</code> est une méthode de classe qui s'appelle sur une classe entière (en faisant <code>NomDeTaClasse.truc</code>). Une méthode <code>truc</code> est une méthode d'instance qui s'appelle sur une instance (en faisant <code>nom_de_l_instance.truc</code>).</p>
      <p>Prenons l'exemple de ton potin : si tu veux sauvegarder un potin <code>mon_potin</code> pour le mettre en base, tu ne vas pas faire <code>Gossip.save</code>, mais plutôt <code>mon_potin.save</code>. La sauvegarde est plutôt une méthode d'instance. <br>
      Idem pour retourner la liste des potins que tu as en base, tu ne vas pas faire <code>mon_potin.all</code>, mais plutôt <code>Gossip.all</code>. Récupérer toutes les instances en base est plutôt une méthode de classe.</p>
      <p>Deuxième exemple (et on passe à la suite promis), si tu devais recoder la méthode <code>new</code> (à ne jamais faire), et bien tu ferais <code>self.new</code> car tu créés un potin en faisant <code>Gossip.new</code>, et non pas en faisant <code>mon_potin.new</code>.</p>
    </div>
  </div>
</div>


<h5>2.3.4. La view</h5>
<p>Maintenant que tu as une array qui contient tous les potins de ta base, tu as juste à la donner à la view, pour qu'elle les affiche. Une méthode <code>index_gossips(gossips)</code> qui contient l'array de tes potins en paramètres fera très bien l'affaire. En faisant faire à cette méthode un petit <code>.each</code> sur ton array, tu pourras <code>puts</code> chaque potin du array. Et voilà, tu as affiché les potins de ta base !</p>

<h5>2.3.5. Index terminé !</h5>
<p>Pfiou ! Tu es en grande forme aujourd'hui ! Tu commences à maîtriser super bien le MVC, et maintenant tu vas pouvoir passer à la fonctionnalité suivante : la possibilité de détruire un potin. 💣</p>

<h4>2.4. Destroy</h4>
<p>Pour cette dernière méthode, un peu plus complexe que les deux autres, nous allons te laisser gérer le truc, comme un grand. Il existe plein de méthodes différentes, mais en gros le programme va demander à l'utilisateur quel potin il veut supprimer, puis le programme le retirera ce potin du CSV.</p>

<h4>2.5. Et voilà</h4>
<p>Et bien bravo, tu as réussi à faire une application qui propose à l'utilisateur de balancer ses potins sur THP, en mode MVC. Bien joué, et on espère que la fierté s'empare de toi.</p>

<h3>3. Rendu attendu</h3>
<p>Tu devras rendre une application qui demande en boucle à l'utilisateur s'il veut afficher, créer, ou détruire des potins. Si tu fermes l'application, les données restent sauvegardées grâce à un système de gestion de base de données en CSV ou en JSON.</p>

<p>Voici l'arborescence du programme :</p>
<pre><code class="language-shell">.
├── lib
│    ├── controller.rb
│    ├── gossip.rb
│    ├── router.rb
│    └── view.rb
├── db
│   └── gossip.csv
├── app.rb
├── Gemfile
└── Gemfile.lock</code></pre>
          </div>
        </div>
        </div>
      </div>
    </div>
  </div>
</div>



</div>


  </div>
</div>
    <script src="/packs/dashboard-031178fac0de4f91cbcc.js"></script>
    

    <script charset="utf-8">
      $('input[name=authenticity_token]').val($('meta[name=csrf-token]').attr('content'));
    </script>

  </body>
</html>
