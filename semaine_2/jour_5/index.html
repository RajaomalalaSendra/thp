<!DOCTYPE html>
<html class="loading" lang="fr">
  <head>
<meta charset="utf-8">
    <link rel="stylesheet" type="text/css" href="/thp/style/bootstrap.css">
    <title>The hacking project offline</title>
  </head>
  <body class="vertical-layout vertical-menu 2-columns  menu-expanded fixed-navbar" data-open="click" data-menu="vertical-menu" data-color="bg-gradient-x-primary-blue" data-col="2-columns">
      <nav class="navbar navbar-expand-lg navbar-dark bg-primary">
        <h1 class="navbar-brand">THE HACKING PROJECT</h1>
        <button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarColor01" aria-controls="navbarColor01" aria-expanded="false" aria-label="Toggle navigation">
          <span class="navbar-toggler-icon"></span>
        </button>

        <div class="collapse navbar-collapse" id="navbarColor01">
          <ul class="navbar-nav mr-auto">
            <li class="nav-item active">
              <a class="nav-link" href="/thp">Home</a>
            </li>
            <li class="nav-item">
              <a class="nav-link" href="/thp/features">Features</a>
            </li>
            <li class="nav-item">
              <a class="nav-link" href="/thp/about">About</a>
            </li>
          </ul>
          <form class="form-inline my-2 my-lg-0">
            <input class="form-control mr-sm-2" type="text" placeholder="Search">
            <button class="btn btn-secondary my-2 my-sm-0" type="submit">Search</button>
          </form>
        </div>
      </nav>
<div class="container">
    <a type="button" class="btn btn-dark" href="/thp/semaine_1/">Semaine 1</a>
    <a type="button" class="btn btn-dark" href="/thp/semaine_2/">Semaine 2</a>
    <a type="button" class="btn btn-dark" href="/thp/semaine_3/">Semaine 3</a>
    <a type="button" class="btn btn-dark" href="/thp/semaine_4/">Semaine 4</a>
    <a type="button" class="btn btn-dark" href="/thp/semaine_5/">Semaine 5</a>  
</div>


<div class="app-content content">
  <div class="content-wrapper">
    <div class="content-wrapper-before"></div>
    <div class="content-header row"></div>
    
      <div class="container">
    <div class="card">
  <div class="card-header">
    <h4 class="text-center"> Programme jour par jour</h4>
  </div>
  <div class="card-body">
    <div class="text-center">
    <a href="/thp/semaine_2">
      <button class="btn btn-secondary btn-outline-dark btn mr-4">
        <i class="fa fa-terminal"></i>&nbsp;&nbsp;&nbsp;Lun
      </button>
</a>    <a href="/thp/semaine_2/jour_2">
      <button class="btn btn-secondary btn-outline-dark btn mr-4">
        <i class="fa fa-code"></i>&nbsp;&nbsp;&nbsp;Mar
      </button>
</a>    <a href="/thp/semaine_2/jour_3">
      <button class="btn btn-secondary btn-outline-dark btn mr-4">
        <i class="fa fa-desktop"></i>&nbsp;&nbsp;&nbsp;Mer
      </button>
</a>    <a href="/thp/semaine_2/jour_4">
      <button class="btn btn-secondary btn-outline-dark btn mr-4">
      <i class="fa fa-folder-open"></i>&nbsp;&nbsp;&nbsp;Jeu
      </button>
</a>    <a href="/thp/semaine_2/jour_5">
      <button class="btn btn-secondary btn-outline-dark btn-lg mr-4">
      <i class="fa fa-bullhorn"></i>&nbsp;&nbsp;&nbsp;Ven
      </button>
</a>    </div>
  </div>
</div>


<div class="app-content content">
  <div class="content-wrapper">
    <div class="content-wrapper-before"></div>
    <div class="content-header row"></div>
    
      
<div class="content-body">
      <h2 class="text-center">Automatisation, serialization</h2>
      <h4 class="text-center">Découverte de Ruby</h4>
  <div class="row">
     <div class="col-xl-3 col-lg-6 col-md-12">
  <div class="card">
    <div class="card-content">
      <div class="card-body">
        <div class="media d-flex">
          <div class="align-self-top">
              <i class="ft-calendar icon-opacity info font-large-4"></i>
          </div>
          <div class="media-body text-right align-self-bottom mt-3">
              <span class="d-block mb-1 font-medium-1"></span>
              <h3 class="info mb-0">
                 Jour 24 / 55</h3>
          </div>
        </div>
        <div class="progress progress-sm mt-1 mb-0 box-shadow-2">
            <div class="progress-bar bg-gradient-x-info" role="progressbar" style="width: 43%" aria-valuenow="25" aria-valuemin="0" aria-valuemax="120">
            </div>
        </div>
      </div>
    </div>
  </div>
 </div>


    <div class="col-xl-3 col-lg-6 col-md-12">
  <div class="card">
    <div class="card-content">
      <div class="card-body">
        <div class="media d-flex">
          <div class="align-self-top">
            <i class="ft-heart icon-opacity danger font-large-4"></i>
          </div>
          <div class="media-body text-right align-self-bottom mt-3">
            <span class="d-block mb-1 font-medium-1">Jokers restant</span>
            <h3 class="danger mb-0">
                3
            </h3>
          </div>
        </div>
      </div>
    </div>
  </div>
</div>

    <div class="col-xl-3 col-lg-6 col-md-12">
    <div class="card">
        <div class="card-content">
            <div class="card-body">
                <div class="media d-flex">
                    <div class="align-self-top">
                        <a href="/dashboard/assignments?locale=fr">
                           <i class="ft-fast-forward icon-opacity warning font-large-4"></i>
</a>                    </div>
                    <div class="media-body text-right align-self-bottom mt-3">
                        <span class="d-block mb-1 font-medium-1">Missions</span>
                            <div class="badge border-danger danger badge-border">Pas inscrit</div>
                    </div>
                </div>
            </div>
        </div>
    </div>
</div>

  </div>
  <div class="row">
        <div class="container">
    <div class="col-xl-12 col-lg-12 col-md-12">
    <div class="card">
        <div class="card-header">
        <h1 >Découverte de Ruby
                <i class="fa fa-beer text-warning"></i>
        </h1>
        
        </div>
        <div class="card-content">
        <div class="card-body">
            <div class="card-text">
            <h2 class="text-center">Automatisation, serialization</h2>
            <div class="cd-horizontal-timeline loaded">
                <div class="timeline">
                <div class="events-wrapper">
                    <div class="events" style="width: 1800px;">
                    <ol>
                                <li>
                                    <a style="left:120px;" href="/dashboard/weeks/2/days/1?locale=fr">
                                        Lun
                                            <i class="fa fa-rocket text-danger" aria-hidden="true" data-toggle="tooltip" data-placement="bottom" title="Projet à rendre ce jour-là"></i>

</a>                                </li>
                                <li>
                                    <a style="left:240px;" href="/dashboard/weeks/2/days/2?locale=fr">
                                        Mar
                                            <i class="fa fa-pencil text-success" aria-hidden="true" data-toggle="tooltip" data-placement="bottom" title="Corrections cette journée là" ></i>


</a>                                </li>
                                <li>
                                    <a style="left:360px;" href="/dashboard/weeks/2/days/3?locale=fr">
                                        Mer
                                            <i class="fa fa-beer text-warning" aria-hidden="true" data-toggle="tooltip" data-placement="bottom" title="Rendez-vous pour boire un coup"></i>

</a>                                </li>
                                <li>
                                    <a style="left:480px;" href="/dashboard/weeks/2/days/4?locale=fr">
                                        Jeu
                                            <i class="fa fa-rocket text-danger" aria-hidden="true" data-toggle="tooltip" data-placement="bottom" title="Projet à rendre ce jour-là"></i>

</a>                                </li>
                            <li>
                                <a class="selected" style="left:600px;" data-toggle="tooltip" data-placement="top" title="Automatisation, serialization" href="/dashboard/weeks/2/days/5?locale=fr">
                                    Ven
                                        <i class="fa fa-pencil text-success" aria-hidden="true" data-toggle="tooltip" data-placement="bottom" title="Corrections cette journée là" ></i>


</a>                                </li>
                    </ol>
                </div>
                </div>
            </div>
            </div>
        </div>
        </div>
    </div>
    </div>
<div>
  </div>

  <!-- Les fameuses corrections qui n'arrivnet que les jours concernés -->


    <div class="container">
  <div class="row">
    <div class="col-12">
      <div class="card">
        <div class="card-header" style="border-top: 3px solid #5E66E5 " >
          <h1>Cours : Pimper le terminal</h1>
          <a class="heading-elements-toggle">
          <i class="la la-ellipsis-v font-medium-3"></i>
          </a>
          <div class="heading-elements">
            <ul class="list-inline mb-0">
              <li><a data-action="collapse"><i class="ft-minus"></i></a></li>
              <li><a data-action="expand"><i class="ft-maximize"></i></a></li>
            </ul>
          </div> 
      </div>
      <div class="card-content collapse show">
        <div class="card-body">
          <div class="tab-pane active" id="home1" role="tabpanel">
          
<h2>1. Introduction</h2>
<p>Dans cette ressource nous allons te montrer comment customiser ton terminal. Fini le terminal aubergine de Jean-Michel Ubuntu, ou le vilain terminal noir sur fond blanc de Jeannine MacBook.</p>
<p>Le terminal est ta porte d'entrée vers le monde du code : elle se doit d'être ultra-fonctionnelle pour toi. D'ailleurs on te conseille FORTEMENT de ne plus toucher à l'explorateur de fichier et de tout faire via le terminal : d'ici 2 mois tu seras super à l'aise. Nos astuces de pimp vont t'aider à le manipuler plus vite, à ce qu'il soit plus clair, et à optimiser ce que tu vas faire avec. </p>

<p>Puis nous te montrerons un super logiciel qui s'appelle Oh-My-ZSH qui a plein de fonctionnalités hyper pratiques pour jouer avec ton terminal.</p>

<h2>2. Historique</h2>
<p>Dans l'univers du développement, les devs passent tellement de temps dans leur terminal qu'ils ont rapidement mis en place des moyens d'améliorer leur vitesse de travail : des commandes pour écrire plus vite, ou encore utiliser des couleurs plus agréables quand on navigue dans son terminal.</p>
<p>Parfois ça fait économiser 2 secondes chrono, mais (2 secondes) x (100 fois par jour) x (220 jours par an), ça fait du temps de gagné. Que tu passeras à jouer à Fortnite ou mater des séries sur Netflix, certes, mais quand même. </p>

<h2>3. La ressource</h2>
<p>Étant donné que Linux est différent de macOS, cette ressource mentionnera les deux cas. Reportez-vous aux bonnes sections en fonction de l'OS de votre ordinateur ! 😉</p>

<h3>3.1. Un meilleur terminal</h3>
<p>Le terminal de base est assez limité, par exemple, il n'est pas possible d'ouvrir plusieurs onglets dans le même terminal, qui seraient autant de consoles différentes (cf. exemple ci-dessous).</p>

<img src="https://i.imgur.com/E2Qaj0E.png" class="img-fluid"><br><br>

<p>Nous allons donc te montrer des meilleurs terminaux à installer.</p>

<h4>3.1.1. Ceux qui sont sur Linux</h4>
<h5>a) Installer Terminator</h5>
<p>Personnellement, j'utilise <a href="https://gnometerminator.blogspot.com/p/introduction.html" target="_blank">Terminator</a>, un super terminal qui a plein de fonctionnalités pratiques (comme avoir plusieurs onglets dans la même fenêtre).</p>

<p>Il est possible de modifier les couleurs et préférences dans Clic droit -> Preferences -> Profile, puis de s'amuser comme tu veux.</p>

<div class="card box-shadow-0 border-danger">
  <div class="card-content collapse show">
    <div class="card-body">
      <h4 class="card-title">⚠️ ALERTE ERREUR COMMUNE</h4>
      <p class="card-text">Si tu veux que le terminal fonctionne bien avec RVM, il te faut <b>impérativement</b> activer la fonction <code>Run command as login shell</code>, dans les Préférences, comme marqué sur <a href="https://i.stack.imgur.com/8J6OT.png" target="_blank">cette photo</a>.</p>
    </div>
  </div>
</div>


<h5>b) Changer de thème</h5>
<p>Le thème aubergine d’Ubuntu classique est très laid. Ce serait bien de pouvoir lui coller un vrai thème. Eh bien c'est possible grâce à l'onglet "Colors" dans la sélection de profils de Terminator. Solarized Dark est un grand classique.</p>


<div class="card box-shadow-0 border-info">
  <div class="card-content collapse show">
    <div class="card-body">
      <h4 class="card-title">⚠️ ALERTE BONNE ASTUCE</h4>
      <p class="card-text">Si tu trouves (comme moi) que les couleurs proposées par ton Terminator ne sont pas à ton goût, tu peux aussi les modifier manuellement dans le fichier <code>~/.config/terminator/config</code>. Personnellement, je suis très très fan du thème <a href="https://draculatheme.com/" target="_blank">Dracula</a>, que tu peux importer manuellement de <a href="https://github.com/EliverLara/terminator-themes/blob/master/schemes/Dracula.config" target="_blank">ici</a>.</p>
    </div>
  </div>
</div>

<h4>3.1.2. Ceux qui sont sur macOS</h4>
<h5>a) Installer iTerm2</h5>
<p>Personnellement, j'utilise <a href="https://www.iterm2.com/" target="_blank">iTerm2</a>, un super terminal qui a plein de fonctionnalités pratiques (comme avoir plusieurs vues dans la même fenêtre).</p>

<p>Il est possible de modifier les couleurs et préférences dans Préférences -> Profil, puis de s'amuser comme tu veux.</p>


<h5>3.1.2.2. Un thème</h5>
<p>Le thème noir sur fond blanc du terminal classique est très laid. Ce serait bien de pouvoir lui coller un vrai thème. Eh bien c'est possible grâce au boutont "Color presets" dans l'onglet "Colors" dans la sélection de profils d’iTerm2. Solarized Dark est par exemple un grand classique, mais je suis extrêmement fan de <a href="https://draculatheme.com/iterm/" target="_blank">Dracula</a>.</p>

<h3>3.2. Aliases, prompt</h3>
<p>Ouvre une nouvelle fenêtre de terminal et rentres-y la ligne suivante :</p>
<pre><code class="language-shell">$ alias gs="git status"</code></pre>

<p>Si tu rentres <code>$ gs</code> dans ton terminal, ce dernier devrait exécuter la commande <code>git status</code>. "Wowowow, cela veut dire que l'une des commandes que j'utilise le plus peut être raccourcie, et ainsi me faire gagner de précieuses secondes ?" Oui : c'est ce qu'on appelle un alias. Par contre si tu fermes ton terminal, cet alias temporaire va disparaître et ne fonctionnera plus. <br> Nous allons voir comment faire en sorte que ton terminal charge la ligne <code>alias gs="git status"</code> à chaque démarrage 🤘.</p>

<h4>3.2.1. bash_profile</h4>
<p>Quand tu ouvres une nouvelle fenêtre de terminal, ce dernier va charger et exécuter toutes les lignes d'un fichier. En fonction de si tu es en <i>login shell</i>, ce dernier va exécuter :</p>

<ul>
  <li>Le fichier <code>~/.bashrc</code> si tu n'es pas en <i>login shell</i></li>
  <li>Le fichier <code>~/.bash_profile</code> si tu es en <i>login shell</i></li>
</ul>

<p>Si tu es sous macOS, tu es de base en <i>login shell</i>. <br>
  Si tu es sous Linux, nous t'avons demandé de <a href="https://i.stack.imgur.com/8J6OT.png" target="_blank">cocher la fameuse case</a> donc tu es aussi en <i>login shell</i>. <br>
  Bref, tout cela pour dire que dans les deux cas, ton terminal exécutera les lignes du fichier <code>~/.bash_profile</code> à chaque ouverture de fenêtre. Nous allons donc compléter ton <code>~/.bash_profile</code> pour améliorer ton terminal !</p>


<div class="card box-shadow-0 border-danger">
  <div class="card-content collapse show">
    <div class="card-body">
      <h4 class="card-title">⚠️ ALERTE ERREUR COMMUNE</h4>
      <p class="card-text">Si tu ne trouves pas de fichier <code>~/.bash_profile</code>, c'est qu'il te faut le créer ! Va à la racine avec un <code>$ cd</code>, fais un <code>$ touch .bash_profile</code> et éventuellement copie-colle le contenu de ton <code>.bashrc</code> dedans (notamment s'il contenait déjà des commandes utiles).</p>
    </div>
  </div>
</div>


<p>Commençons par tester le fonctionnement du <code>~/.bash_profile</code> : ouvre-le dans un éditeur de texte et mets-y la ligne suivante (tout en bas) qui est rédigée en langage Shell.</p>

<pre><code class="language-shell">echo "Bonjour du fichier .bash_profile !"</code></pre>

<p>Ouvre une nouvelle fenêtre de terminal, tu devrais avoir une ligne <code>Bonjour du fichier .bash_profile !</code> qui s'affiche en haut de ton terminal 😉</p>

<div class="card box-shadow-0 border-danger">
  <div class="card-content collapse show">
    <div class="card-body">
      <h4 class="card-title">⚠️ ALERTE ERREUR COMMUNE</h4>
      <p class="card-text">Si tu as installé un logiciel supplémentaire à ton terminal (On-My-ZSHpar exemple), ce dernier ne lira pas le fichier <code>~/.bash_profile</code>, mais un autre. C'est normal qu'il n'affiche pas la fameuse ligne donc.</p>
    </div>
  </div>
</div>

<p>Maintenant que ton fichier <code>~/.bash_profile</code> est bien lu, nous allons y insérer des aliases.</p>

<h4>3.2.2. Alias</h4>
<p>Nous avons vu plus haut qu'il est possible de créer des raccourcis (ou alias) pour tes commandes préférées. Entre dans ton fichier <code>~/.bash_profile</code> et mets-y les lignes suivantes :</p>

<pre><code class="language-shell">alias g='git'
alias gs='git status'
alias ga='git add'
alias gc='git commit -m'
alias ll='ls -las'</code></pre>

<p>Ainsi, à chaque fois que tu ouvriras une fenêtre de terminal, ce dernier va charger toutes ces lignes, et te mettre à dispo ces alias qui vont te faire gagner plein de temps. Plutôt cool, non ? Tu peux bien entendu laisser libre cours à ton imagination pour en créer d'autres. Généralement, c'est en fin de session (juste avant les projets finaux) que l'on sait le mieux quelle commande on ne supporte plus de rentrer à la main.</p>


<h4>3.2.3. Le prompt</h4>
<p>Le prompt est la suite de caractère qui commence chaque ligne de terminal. De base, sur macOS ou Linux, c'est aussi déprimant qu'un nouvel an, seul devant Motus. Illustration : </p>
<pre><code class="language-bash">user@username:~$</code></pre>

<p>Nous allons voir comment le changer pour te donner envie de bosser et rendre l’usage du terminal plus clair. Teste dans ton terminal la ligne suivante :</p>

<pre><code class="language-shell">$ export PS1="\h\n\\$ \[$(tput sgr0)\]"</code></pre>

<p>Maintenant ce dernier devrait à chaque nouvelle ligne écrire :</p>

<pre><code class="language-bash">ton_username
$ </code></pre>

<p>En effet, nous avons modifié le PS1 de ton terminal, la variable qui définit la tronche de ton prompt. Avec un langage très chelou nous lui avons dit d'écrire : <code>username</code> <code>retour à la ligne</code> <code>$</code> <code>espace</code> à chaque nouvelle ligne de terminal. <br>
Cette technique est temporaire (si tu fermes le terminal on revient à l'ancien prompt), mais figure-toi qu'on peut saisir cette ligne dans le fichier <code>~/.bash_profile</code> et ainsi changer définitivement ton prompt.</p>

<div class="card box-shadow-0 border-danger">
  <div class="card-content collapse show">
    <div class="card-body">
      <h4 class="card-title">⚠️ ALERTE ERREUR COMMUNE</h4>
      <p class="card-text">Idem que pour tout à l'heure, Oh-My-ZSH change tout ceci ;) Si tu es un peu flemmard et que tu veux aller à l'essentiel, passe ton chemin et va directement à la section 3.3. pour installer Oh-My-ZSH</p>
    </div>
  </div>
</div>

<p>Avec le site <a href="http://bashrcgenerator.com/" target="_blank">bashrcgenerator</a>, tu peux facilement customiser un PS1, ajouter des couleurs, l'heure, bref ce que tu veux. Et si tu as la flemme de chercher, voici le PS1 que j'avais avant de passer à Oh-My-ZSH :</p>

<pre><code class="language-shell">export PS1="\n\[$(tput sgr0)\]\[\033[38;5;9m\]\u\[$(tput sgr0)\]\[\033[38;5;15m\] \[$(tput sgr0)\]\[\033[38;5;39m\]😊 \[$(tput sgr0)\]\[\033[38;5;15m\] \[$(tput sgr0)\]\[\033[38;5;10m\]\w\[$(tput sgr0)\]\[\033[38;5;15m\]\n\[$(tput sgr0)\]\[\033[38;5;214m\]\D{%T}\[$(tput sgr0)\]\[\033[38;5;15m\] \[$(tput sgr0)\]\[\033[38;5;254m\]\\$\[$(tput sgr0)\]\[\033[38;5;15m\] \[$(tput sgr0)\]"</code></pre>

<p>En plus d'être sympathique et coloré, ce prompt est assez clair, car le chemin des fichiers <code>~/Documents/THP/Semaine_1/</code> n'est pas sur la même ligne que la saisie de ta ligne de commande. Fini les commandes à taper parfois à gauche de l'écran, parfois au milieu en fonction de la longueur de ton chemin ! Et puis t'as l'heure, ça c'est cool. </p>


<h3>3.3. Oh-My-ZSH</h3>
<p>Tu as entendu parler tout au long de cette ressource un truc bizarre appelé Oh-My-ZSH. Qu’est-ce que c'est ?</p>

<p><a href="https://ohmyz.sh/" target="_blank">Oh-My-ZSH</a> est une suite de scripts que ton terminal va faire tourner avant de se charger. L'avantage est que tous ces scripts vont te donner des possibilités assez avancées : imagine par exemple un script qui va vérifier là où tu en es sur Git et te donne <b>dans ton prompt</b> le nom de la branche dans laquelle tu es. Ou alors un script qui fait des propositions dynamiques que tu peux accepter en faisant <code>TAB</code> <code>TAB</code>. Tu peux le coder toi-même, mais pourquoi se prendre la tête quand des développeurs bien meilleurs que toi l'ont déjà fait ?? </p>

<h4>3.3.1. Installer Oh-My-ZSH</h4>
<p>Pour ceci, il suffit juste de <a href="https://github.com/robbyrussell/oh-my-zsh/" target="_blank">suivre la doc</a> !</p>

<h4>3.3.2. le fichier .zshrc</h4>
<p>À partir de maintenant, dès que ton terminal va ouvrir une nouvelle fenêtre, ce dernier ne va plus exécuter le fichier <code>~/.bash_profile</code>, mais il va exécuter le fichier <code>~/.zshrc</code>. Ce dernier devrait ressembler à <a href="https://github.com/robbyrussell/oh-my-zsh/blob/master/templates/zshrc.zsh-template" target="_blank">ceci</a>, aura plein de lignes bizarres, mais si tu lis, tu peux à peu près comprendre que c'est un fichier de configuration.</p>

<h5>3.3.2.1. Les lignes classiques de ton fichier .bash_profile</h5>
<p>Tous les aliases que tu trouvais cool peuvent être copiés dans le fichier <code>~/.zshrc</code>. En ce qui concerne le changement de prompt et le PS1, étant donné que tu vas passer par les thèmes Oh-My-ZSH, pas besoin d'importer ce dernier.</p>

<h5>3.3.2.2. Les plugins</h5>
<p>oh-my-zsh vient avec plein de plugins sympa que tu peux modifier avec <a href="https://github.com/robbyrussell/oh-my-zsh#plugins" target="_blank">les lignes de plugin</a>. Tu peux voir une liste plugins officiels <a href="https://github.com/robbyrussell/oh-my-zsh/wiki/Plugins" target="_blank">dans leur wiki</a>. Les plugins <a href="https://github.com/robbyrussell/oh-my-zsh/wiki/Plugins#rails" target="_blank">Rails</a>, <a href="https://github.com/robbyrussell/oh-my-zsh/wiki/Plugins#git" target="_blank">Git</a>, et <a href="https://github.com/robbyrussell/oh-my-zsh/wiki/Plugins#ruby" target="_blank">Ruby</a> peuvent t'intéresser par exemple.</p>

<h5>3.3.2.3. Les thèmes</h5>
<p>L'autre point fort de Oh-My-ZSH est la quantité astronomique de thèmes, que tu peux modifier comme tu veux. Tu peux trouver <a href="https://github.com/robbyrussell/oh-my-zsh/wiki/Themes" target="_blank">ici</a> la liste de thèmes officiels. Pour toi, voici une sélection de thèmes sympas :</p>

<ul>
  <li>Le thème par défaut que personnellement j'utilise : <a href="https://github.com/robbyrussell/oh-my-zsh/wiki/Themes#robbyrussell">robbyrussell</a>.</li>
  <li>Un thème très célèbre utilisé par Zaratan (si tu ne vois pas de qui il s'agit, c'est que tu n'es pas assez sur Slack) : <a href="https://github.com/robbyrussell/oh-my-zsh/wiki/Themes#agnoster" target="_blank">agnoster</a>.</li>
  <li>Simple mais efficace : <a href="https://github.com/robbyrussell/oh-my-zsh/wiki/Themes#ys" target="_blank">ys</a>.</li>
  <li>Enfin, un thème que j'ai utilisé pendant très longtemps qui demande une installation custom : <a href="https://github.com/denysdovhan/spaceship-prompt" target="_blank">spaceship</a>.</li>
</ul>


<h2>4. Points importants à retenir</h2>
<p>Change de terminal, créé tes alias, installe Oh-My-ZSH et apprécie, enfin, de bosser sur ton tout nouveau terminal !</p>

<h2>5. Pour aller plus loin</h2>
<p>Tout ceci s'appelle les dotfiles. Lars Kappert a écrit une série d'articles <a href="https://medium.com/@webprolific/getting-started-with-dotfiles-43c3602fd789" target="_blank">sur les dotfiles</a> que tu peux lire pour aller plus loin dans la customisation de terminal.</p>

          </div>
        </div>
        </div>
      </div>
    </div>
  </div>
</div>

  <div class="container">
  <div class="row">
    <div class="col-12">
      <div class="card">
        <div class="card-header" style="border-top: 3px solid #5E66E5 " >
          <h1>Cours : Jouer avec son ordinateur avec Ruby !</h1>
          <a class="heading-elements-toggle">
          <i class="la la-ellipsis-v font-medium-3"></i>
          </a>
          <div class="heading-elements">
            <ul class="list-inline mb-0">
              <li><a data-action="collapse"><i class="ft-minus"></i></a></li>
              <li><a data-action="expand"><i class="ft-maximize"></i></a></li>
            </ul>
          </div> 
      </div>
      <div class="card-content collapse show">
        <div class="card-body">
          <div class="tab-pane active" id="home1" role="tabpanel">
          <h2>1. Introduction</h2>
<p>Jusque-là, nous avons utilisé Ruby pour interagir avec le terminal (via des petits programmes basiques) ou des sites web (en scrapping). Mais Ruby est un langage très puissant que tu peux aussi utiliser pour automatiser des tâches directement sur ton ordinateur. On va te montrer comment faire.</p>

<h2>2. Historique</h2>
<p>L'informatique, cela ne sert pas qu'à faire des applications web ! Figure-toi qu'au début cela servait à interagir avec son ordinateur (si si !).</p>

<h2>3. La ressource</h2>

<h3>3.1. Jouer avec des fichiers et dossiers</h3>

<h4>3.1.1. Les dossiers</h4>
<p>Pour faire créer un dossier par un programme Ruby, il suffit qu'il exécute :</p>

<pre><code class="language-ruby">Dir.mkdir("nom_du_dossier")</code></pre>

<p>Cette ligne aura pour effet de créer un sous-dossier directement dans le dossier où le programme se trouve. Si tu veux créer un dossier dans un endroit précis, tu devras le faire en précisant le chemin dossier souhaité depuis la racine. Pour avoir un exemple de chemin complet, tape <code>$ pwd</code> dans ton terminal. <br>
Ainsi, si je veux créer un dossier sur mon bureau, je ferai :</p>

<pre><code class="language-ruby">Dir.mkdir("/home/felix/Desktop/nom_du_dossier")</code></pre>

<p><a href="https://ruby-doc.org/core-2.5.1/Dir.html" target="_blank">La documentation de Ruby</a> pourra te donner plein d'autres méthodes pour jouer avec des dossiers.</p>

<h4>3.1.2. Les fichiers</h4>
<h5>a) Ouvrir un fichier</h5>
<p>Avec Ruby, il est très aisé de manipuler des fichiers : la classe <code>File</code> permet de faire exactement ceci. Voici comment s'en servir :</p>

<pre><code class="language-ruby">file = File.open("chemin/vers/ton/fichier.extension", "droits")</code></pre>
<p>Si on décompose cette commande :</p>
<ul>
  <li>Tu n'es pas obligé d'affecter cela à une variable avec <code>file = </code>, mais en faisant cela, tu pourras interagir facilement avec ton fichier.</li>
  <li>Le <code>chemin/vers/ton/fichier.extension</code> est comme pour la création de dossier : Ruby prendra le chemin à partir de là où se trouve ton programme ou bien depuis la racine.</li>
  <li>Concernant les droits, ils définissent et limitent ce que tu vas faire dans ton fichier. Il existe 6 types de droits :</li>
  <ul>
    <li><code>r</code>, pour "<i>reading</i>" : tu vas pouvoir lire le fichier, voir ce qu'il y a écrit dedans.</li>
    <li><code>a</code>, pour "<i>append</i>" : tu vas pouvoir ajouter des lignes à ton fichier.</li>
    <li><code>w</code>, pour "<i>write</i>" : tu vas réécrire intégralement ton fichier. S'il y a déjà un fichier, il efface tout pour repartir de 0. S'il n'y a pas de fichier, il en crée un.</li>
    <li><code>w+</code>, pour "<i>write and read</i>" : tu vas pouvoir réécrire intégralement ton fichier (cf. ci-dessus), et tu peux aussi lire ce qu'il y a dedans.</li>
    <li><code>a+</code>, pour "<i>append and read</i>" : tu vas pouvoir ajouter des lignes à ton fichier, et aussi pouvoir lire ce qu'il y a dedans.</li>
    <li><code>r+</code>, pour "<i>read and write</i>" : tu vas pouvoir modifier ton fichier sans tout effacer</li>
  </ul>
</ul>

<p>Donc si tu veux créer un fichier nommé <code>index.html</code> dans le même dossier que ton programme, il te faudra écrire :</p>

<pre><code class="language-ruby">File.open("index.html", "w")</code></pre>


<h5>b) Quelques méthodes de fichier</h5>
<p>Voici quelques méthodes qui peuvent te faire interagir avec ton fichier lié à la variable <code>file</code> :</p>

<ul>
  <li><code>file.puts(string)</code> : permet d'insérer la ligne <code>string</code> dans ton fichier lié à <code>file</code>.</li>
  <li><code>file.read</code> : te retourne le fichier comme étant un grand string où les retours à la ligne sont remplacés par <code>\n</code> (c'est comme ça que l'on fait un retour à la ligne en langage code).</li>
  <li><code>file.close</code> : permet de fermer le fichier et de ne plus le rendre disponible en lecture/écriture via <code>file</code>.</li>
  <li><code>file.each</code> : la variable <code>file</code> peut être considérée comme un array dont chaque élément est un string contenant une ligne de ton fichier. Avec <code>.each</code> tu peux travailler sur chaque ligne</li>
</ul>
<p>Il existe plein d'autres méthodes que tu peux voir sur <a href="http://ruby-doc.org/core-2.3.0/IO.html" target="_blank">la doc</a>. Tu peux trouver facilement des tutos aussi, comme <a href="http://rubylearning.com/satishtalim/read_write_files.html" target="_blank">celui-ci</a>/.</p>

<p>Bien évidemment, pour que ces méthodes marchent comme souhaité, tu dois avoir les bons droits. Inutile de faire <code>file.read</code> si tu n'as pas ouvert ton fichier avec les droits de lecture 😉</p>

<h5>c) Exemples</h5>

<p>Puisque c'est toi, voici un programme qui va ajouter la gem PRY au fichier Gemfile se trouvant là où tu exécutes le programme, puis imprimer dans ton termina le contenu global du Gemfile:</p>

<pre><code class="language-ruby">file = File.open("Gemfile", "a")
file.puts("gem 'pry'")
file.close

file = File.open("Gemfile", "r")
puts "Voici le contenu de ton Gemfile :"
puts file.read
file.close</code></pre>

<h3>3.2. Lancer des commandes de Shell</h3>
<p>Shell c'est le langage que parle ton terminal : c'est un langage de programmation à part entière. <br>
Sache, pour ta culture générale, qu'avec Ruby, tu peux facilement exécuter des commandes de Shell avec la méthode <code>system(ta_commande_en_shell)</code>. Ainsi, pour faire un <code>$ pwd</code>, tu écriras dans ton programme Ruby :</p>

<pre><code class="language-ruby">system("pwd")</code></pre>



<h3>3.3. ARGV</h3>
<h4>3.3.1. C'est quoi ?</h4>
<p>Certains programmes nécessitent un input de l'utilisateur. Et quand on peut le faire, autant que cet input soit saisi <b>en même temps</b> que l'exécution du programme. Pour illustrer ça, imagine si la commande <code>$ mkdir</code> fonctionnait ainsi pour créer un dossier <code>THP</code>:</p>

<pre><code class="language-shell"></code>$ mkdir
Quel est le nom du dossier que tu veux créer ?
> THP</pre>

<p>C'est nul, non ? Le mec qui a développé cette commande a eu 1000 fois raison de permettre de taper directement <code>$ mkdir THP</code> : c'est beaucoup plus rapide et efficace. Eh bien figure-toi qu'en Ruby il est possible de récupérer les strings saisis juste à la suite de la commande <code>$ ruby nom_du_programme.rb</code> avec un petit <code>ARGV</code>. Pour bien que tu comprennes, on va tester avec un programme simple.</p>

<p>Crée un fichier <code>test.rb</code> avec les lignes suivantes :</p>

<pre><code class="language-ruby">puts "Début du programme"

puts ARGV

puts "Fin du programme"</code></pre>

<p>Exécute <code>$ ruby test.rb</code>. Le programme devrait t'afficher :</p>
<pre><code class="language-shell">Début du programme
Fin du programme</code></pre>

<p> <code>puts ARGV</code> est considéré comme vide. Intéressant. <br>
Maintenant exécute <code>$ ruby test.rb salut</code>. Tiens, on a un petit string <code>salut</code> qui s'est rajouté ! <br>
Dernier essai, exécute <code>$ ruby test.rb salut les amis</code>. Maintenant c'est 3 lignes qui se sont rajoutés:</p>
<pre><code class="language-shell">Début du programme
Salut
les
amis
Fin du programme</code></pre>

<p> Tu as dû comprendre la logique : la variable <code>ARGV</code> récupère ce que l'utilisateur a écrit APRES la commande d'exécution du programme puis met chaque suite de caractères dans un élément d'un array. Tu peux tout à fait utiliser cet array dans ton programme comme une entrée !</p>


<h4>3.3.2. Petit exemple avec un programme qui crée un dossier</h4>
<p>Pour s'entraîner, nous allons recoder <code>mkdir</code> en Ruby 🍻</p>

<p>L'utilisateur va rentrer le nom du dossier qu'il veut créer <b>en même temps qu'il lancera le programme</b></p>
<ul>
  <li>Si l'utilisateur rentre un mot au lancement du programme, ce dernier va créer un dossier là où il se trouve.</li>
  <li>Si l'utilisateur rentre plusieurs mots, le programme ne va créer que le premier dossier demandé.</li>
  <li>Si l'utilisateur ne rentre pas de suite de caractères, le programme va l'engueuler.</li>
</ul>

<p>Faisons la première partie : vérifier que l'utilisateur a bien saisi une suite de caractères et faire réagir le programme dans le cas contraire. <br>S'il ne l'a pas fait, <code>ARGV</code> sera vide. Il existe <a href="https://ruby-doc.org/core-2.5.1/Array.html#method-i-empty-3F" target="_blank">une méthode</a> qui vérifie exactement cela. Puis avec <a href="https://stackoverflow.com/questions/6804237/ending-ruby-program-if-a-given-condition-is-met" target="_blank">une recherche Google</a>, on trouve facilement la méthode <code>#abort</code> qui nous plait bien. Commençons donc notre programme :</p>

<pre><code class="language-ruby">def check_if_user_gave_input
  abort("mkdir: missing input") if ARGV.empty?
end</code></pre>

<p>Top, maintenant récupérons le nom du dossier que l'on veut créer. Pour cette méthode, nous n'allons prendre en considération que le premier string donné par l'utilisateur, mais il serait très simple de créer plusieurs dossiers à la suite avec un <code>.each</code> : </p>

<pre><code class="language-ruby">def get_folder_name
  return folder_name = ARGV.first
end</code></pre>

<p>Enfin, il ne reste plus qu'à créer le dossier avec le nom du dossier récupéré :</p>

<pre><code class="language-ruby">def create_folder(name)
  Dir.mkdir(name)
end</code></pre>

<p>Il ne reste plus qu'à imbriquer les méthodes convenablement, et à toi la gloire ! Je te laisse quand même faire cette dernière étape… non mais. <br>
Tu viens de recoder un équivalent low cost de mkdir, ce qui est quand même un sacré challenge. Bravo, tu peux être fier de toi.</p>

<p><b>PETIT BONUS</b> : si tu mets ce programme dans un dossier bien défini et que tu branches un alias du genre :</p>

<pre><code class="language-shell">alias mkdiruby="ruby /home/ton/chemin/vers/dossier/mkdiruby.rb"</code></pre>

<p>Et bien tu peux utiliser ton programme Ruby de ton terminal, en lieu et place du <code>$ mkdir</code> d'origine !</p>

<h2>4. Points importants à retenir</h2>
<p>En Ruby, il est facile de jouer avec les fichiers et dossiers de ton ordinateur.</p>
<p>Tu peux aussi lancer des commandes de Shell avec <code>system()</code>.</p>
<p>Enfin, ARGV permettra de récupérer ce que l'utilisateur a mis comme input à l'exécution de son programme.</p>

<h2>5. Pour aller plus loin</h2>
<p>Cette ressource, c'est déjà pas mal.</p>
          </div>
        </div>
        </div>
      </div>
    </div>
  </div>
</div>

  <div class="container">
  <div class="row">
    <div class="col-12">
      <div class="card">
        <div class="card-header" style="border-top: 3px solid #5E66E5 " >
          <h1>Cours : Bonus :  Watir</h1>
          <a class="heading-elements-toggle">
          <i class="la la-ellipsis-v font-medium-3"></i>
          </a>
          <div class="heading-elements">
            <ul class="list-inline mb-0">
              <li><a data-action="collapse"><i class="ft-minus"></i></a></li>
              <li><a data-action="expand"><i class="ft-maximize"></i></a></li>
            </ul>
          </div> 
      </div>
      <div class="card-content collapse show">
        <div class="card-body">
          <div class="tab-pane active" id="home1" role="tabpanel">
          <h2>1. Introduction</h2>
<p>On va te présenter un des outils les plus stylés de toute la formation : Watir. Cette gem te permet de créer un bot qui se balade sur internet via un vrai navigateur web, clique là où tu lui demandes de cliquer, tape les mots que tu lui demandes de taper et récupère les informations que tu veux.</p>
<p>En plus d'être très utile, tu verras que c'est un programme super visuel : on voit le navigateur s'ouvrir et s'animer avec les commandes qu'on a programmées. Ultra classe à montrer à tes potes qui se demandent ce que t'apprends, concrètement, chez THP. Tu peux enfin te la péter comme l'expert-hackeur de NCIS et ses programmes autonomes qui popent de partout sur son écran.</p>

<h2>2. Historique</h2>
<p>Watir a été créé, à la base, pour faire du test sur des sites web (<a href="https://www.youtube.com/watch?v=NGu1YlXHVFM"  target="_blank" class="text-primary">lol oups</a>), mais à présent, la gem est surtout utilisée pour faire des bots qui simulent un utilisateur sur un site web.</p>

<h2>3. La ressource</h2>
<p>Watir est un outil indispensable quand il s'agit, par exemple, de scraper le web mais qu'une interaction avec le navigateur est indispensable pour accéder à la donnée. Exemple simple : tu veux scrapper des articles abonnés de lequipe.fr. Impossible à faire sans te loguer avec ton compte abonné. Watir va pouvoir t'aider en "cliquant" sur le lien de login, en rentrant tes identifiants puis en procédant au scrapping.</p>

<p>Pour découvrir tout ça :</p>
<ul>
  <li>J'ai fait un petit article tutoriel sur Watir que tu peux trouver <a href="http://intro-scrap-watir.surge.sh/" target="_blank" class="text-primary">ici</a></li>
  <li><a href="http://watir.com/guides/" target="_blank"  class="text-primary">La doc</a> décrit tout plein de fonctions cools que tu peux utiliser.</li>
</ul>

<h2>4. Points importants à retenir</h2>
<p>Watir, c'est un outil ultra puissant en open-source ! Fais-toi plaisir avec.</p>
          </div>
        </div>
        </div>
      </div>
    </div>
  </div>
</div>


  <div class="container">
  <div class="row">
    <div class="col-12">
      <div class="card">
        <div class="card-header" style="border-top: 3px solid #FF4081 " >
          <h1>Projet : Création de programmes qui automatisent tes tâches quotidiennes</h1>
          <a class="heading-elements-toggle">
          <i class="la la-ellipsis-v font-medium-3"></i>
          </a>
          <div class="heading-elements">
            <ul class="list-inline mb-0">
              <li><a data-action="collapse"><i class="ft-minus"></i></a></li>
              <li><a data-action="expand"><i class="ft-maximize"></i></a></li>
            </ul>
          </div> 
      </div>
      <div class="card-content collapse show">
        <div class="card-body">
          <div class="tab-pane active" id="home1" role="tabpanel">
          <h2>1. Introduction</h2>
<p>Les ressources du jour t'ont permis de mieux comprendre comment marche ton ordinateur, et comment faire des programmes qui vont dans ses entrailles. Nous allons te donner deux projets qui vont te montrer les possibilités énormes d'automatisation que te procure Ruby.</p>

<p>Le premier programme est une mise en bouche qui va te faire faire un raccourci pour lancer une recherche rapide sur Google. Ton programme vient de balancer une erreur ? Au lieu de prendre du temps de changer de fenêtre, ouvrir un onglet Chrome, faire la recherche, tu vas coder un programme qui fera tout cela à ta place.


<p>Le second programme est un créateur de dossier Ruby bien ordonné. Marre de créer le dossier lib, le Gemfile, le dossier spec à chaque fois que tu crées un dossier Ruby ? Et bien on va automatiser tout cela avec Ruby.</p>

<h2>2. Le projet</h2>
<h3>2.1. GoogleSearcher</h3>
<p>Le but du programme est que quand l'utilisateur rentre :</p>
<pre><code class="language-shell">$ ruby google_searcher.rb how to center a div</code></pre>

<p>Ce dernier ouvre un onglet Google Chrome (ou équivalent) et lance une recherche google avec ce que l'utilisateur a rempli.</p>

<p>Ce programme est plutôt simple :</p>
<ul>
	<li>L'utilisateur rentre un ARGV à l'exécution du programme</li>
	<li>Si ce dernier ne rentre pas d'ARGV, le programme va lui dire comment ça marche</li>
	<li>L'ARGV correspond à ce que l'utilisateur veut rechercher sur Google</li>
	<li>Le programme va récupérer l'ARGV, contruire une URL à partir de l'ARGV</li>
	<li>Puis le programme va ouvrir un nouvel onglet à partir de cette recherche</li>
</ul>

<h4>2.1.1. ARGV</h4>
<p>Commence par créer un programme <code>google_searcher.rb</code> qui va récupérer l'ARGV de l'utilisateur. Si l'ARGV est vide, le programme va s'interrompre et il va dire à l'utilisateur comment s'en servir.</p>

<h4>2.1.2. Construire l'url</h4>
<p>Si tu vas sur Google, tu peux remarquer que les recherches que tu fais peuvent être entrées en url après <code>search?q=ta+recherche</code>. Ainsi, l'URL pour la recherche "How to center a div" sera : <a href="https://www.google.com/search?q=how+to+center+a+div" target="_blank">https://www.google.com/search?q=how+to+center+a+div</a>.</p>

<p>À partir de ces informations, il sera très aisé pour toi de construire l'URL avec l'ARGV.</p>

<h4>2.1.3. Ouvrir Google</h4>
<p>Pour ceci, il te faudra utiliser <a href="https://stackoverflow.com/a/152996" target="_blank">la gem Launchy</a>, et à toi la gloire.</p>

<h4>2.1.4. Programme terminé, on fait un alias ?</h4>
<p>Ce qui serait top, serait d'avoir à éviter d'écrire <code>$ /home/ton/chemin/vers/google_searcher.rb how to center a div</code>, ce qui te ferait perdre du temps, et qui rendrait le programme inutile.</p>

<p>Utilise donc un alias qui va appeler ton programme avec un mot très simple, <code>search</code> par exemple. Il devrait ressembler à ceci :</p>

<pre><code class="language-shell">alias search="ruby /home/ton/chemin/vers/google_searcher.rb"</code></pre>

<p>Ainsi, tu peux faire facilement <code>$ search how to center a div</code>.</p>


<h3>2.2. Création d'un dossier ruby</h3>
<p>À chaque fois que nous te demandons de faire une app en Ruby, tu as plein de choses à faire : les dossiers lib, le Gemfile qui contient les bonnes gems, la commande <code>rspec --init</code>, et plein d'autres. Bref, ce serait de pouvoir créer une commande <code>mkdiruby</code>, qui s'occupe de créer tout cela pour nous. Elle marcherait comme <code>mkdir</code>, sauf qu'elle s'occuperait  de tout ce que tu dois faire quand tu créés un dossier Ruby :</p>

<ul>
	<li>Création d'un dossier qui porte le nom de l'ARGV de l'utilisateur
		<ul>
			<li>Si l'utilisateur ne rentre pas de ARGV ou s'il rentre un ARGV avec plusieurs mots, le programme doit dire à l'utilisateur comment s'en servir et s'arrêter</li>
		</ul></li>
	<li>Création du Gemfile avec les gems de THP</li>
	<li>Git init</li>
	<li>Création du fichier <code>.env</code>, puis on le met dans le fichier gitignore</li>
	<li>Création du dossier <code>lib</code></li>
	<li><code>rspec --init</code></li>
	<li>Création d'un Readme.md qui va dire que c'est un programme Ruby</li>
	<li>Évidemment, tu vas créer un alias qui va s'occuper de pouvoir appeler ton programme avec <code>mkdiruby</code> (ou autre)</li>
</ul>

<p>Ce sera l'objectif de ce deuxième programme.</p>

<h2>3. Rendu attendu</h2>
<p>Tu devras rendre deux programmes :</p>

<ul>
	<li>Un programme qui fait une recherche Google</li>
	<li>Un programme qui créé un dossier Ruby entier</li>
</ul>

<p>Exceptionnellement, on ne te demandera pas de faire de tests pour ces programmes.</p>
          </div>
        </div>
        </div>
      </div>
    </div>
  </div>
</div>



</div>


  </div>
</div>
    <script src="/packs/dashboard-031178fac0de4f91cbcc.js"></script>
    

    <script charset="utf-8">
      $('input[name=authenticity_token]').val($('meta[name=csrf-token]').attr('content'));
    </script>

  </body>
</html>
